//===== 熊貓模擬器 (PandasWS/Pandas) 文件 ====================
//= 指令碼指令 (Script Command) 說明文件
//===== 維護人員 =============================================
//= 熊貓模擬器開發團隊
//===== 最後更新 =============================================
//= 20220514 (不一定準)
//===== 文件描述 =============================================
//= 此文件對熊貓模擬器新增的指令碼指令進行說明.
//============================================================

-%TAB%pointshop%TAB%<NPC名稱>%TAB%<外觀編號>,<貨幣變數|貨幣暱稱>{:<折扣>},<出售的道具編號>:<售價>{,<出售的道具編號>:<售價>...}
<地圖名稱>,<X座標>,<Y座標>,<面部朝向>%TAB%pointshop%TAB%<NPC名稱>%TAB%<外觀編號>,<貨幣變數|貨幣暱稱>{:<折扣>},<出售的道具編號>:<售價>{,<出售的道具編號>:<售價>...}

在 rAthena 設計的 pointshop 型別的商店允許我們使用數值變數的值作為貨幣.
這讓我們將類似: 戰場積分、泡點積分 這樣的自定義積分值開放給玩家透過 pointshop 進行道具兌換來說體驗很棒.

在這個設計中唯一美中不足的地方就是每次玩家訪問 pointshop 型別的商店,
程式都會提示玩家當前這個商店使用的變數名稱, 比如你寫:

prontera,150,150,3	pointshop	testshop	123,BattleScoreVar,501:10

他會在每次玩家訪問的時候都告訴玩家這個商店使用: BattleScoreVar 進行結算...
母語不是英文的亞洲玩家看到 BattleScoreVar 會感覺很奇怪, 因為這並不是他熟悉的表述方式,
正因為如此, 支援為貨幣變數起一個別名就變得非常必要.

做法很簡單, 就是在變數名稱末尾使用 | 後面寫上這個貨幣變數的暱稱, 例如:

prontera,150,150,3	pointshop	testshop	123,BattleScoreVar|戰場積分,501:10

這樣玩家訪問這個商店的時候, 程式就會提示玩家這個商店使用: 戰場積分 進行結算.
如此一來體驗就會改善很多... 

這個功能熊貓模擬器很早很早就在程式碼中支援了, 最初可以追溯到 rAthenaCN 專案...
只是一直忘記補充相關的文件, 導致很多朋友在使用上不太方便.

--------------------------------------------------------------

*setheaddir <朝向編號>{,<角色編號>};

調整角色紙娃娃腦袋的朝向

朝向編號:
	0 = 相對於身體朝向的正前方, 頭部看向正前方
	1 = 相對於身體朝向的正前方, 頭部看向右看
	2 = 相對於身體朝向的正前方, 頭部看向左看

角色編號:
	可選引數, 若不攜帶此引數則控制當前指令碼關聯的角色
	若填寫了指定角色編號, 那麼就控制指定角色

返回值:
	該指令無論執行成功與否, 都不會有返回值

--------------------------------------------------------------

*setbodydir <朝向編號>{,<角色編號>};

調整角色紙娃娃身體的朝向

朝向編號:
    1 = 西北      0 = 正北      7 = 東北
              ↖     |     ↗
    2 = 正西  <-     +     ->   6 = 正東
              ↙     |     ↘
    3 = 西南      4 = 正南      5 = 東南

角色編號:
	可選引數, 若不攜帶此引數則控制當前指令碼關聯的角色
	若填寫了指定角色編號, 那麼就控制指定角色

返回值:
	該指令無論執行成功與否, 都不會有返回值

--------------------------------------------------------------

*openbank {<角色編號>};

讓指定的角色立刻開啟銀行介面 (只對擁有隨身銀行的客戶端版本有效).

角色編號:
	可選引數, 若不攜帶此引數則控制當前指令碼關聯的角色
	若填寫了指定角色編號, 那麼就控制指定角色

返回值:
	若開啟銀行失敗則返回 0, 成功則返回 1

--------------------------------------------------------------

*instance_users <副本例項編號>;

獲取指定的副本例項中已經進入副本地圖的人數

副本例項編號:
	必填項, 這裡填寫的副本編號就是 instance_create 指令碼指令返回的那個數值

舉例說明:
	可以用 instance_id 指令碼指令來獲得當前隊伍關聯的副本例項編號
	
	.@party_instance_id = instance_id(IM_PARTY);
	if (.@party_instance_id == 0) {
		dispbottom "你的隊伍當前並沒有建立副本.";
	}
	dispbottom "副本地圖中當前人數: " + instance_users(.@party_instance_id) + " 人";

返回值:
	成功直接返回副本中的人數, 副本不存在或副本中無人存在則返回 0

--------------------------------------------------------------

*cap <要判斷的數值>,<最小值>,<最大值>;

確保數值不低於給定的最小值, 不超過給定的最大值

要判斷的數值:
	必填項, 數值型別的值

最小值:
	必填項, 數值型別的值

最大值:
	必填項, 數值型別的值

不推薦使用:
	rAthena 已經推出了功能完全一致的指令 cap_value;
	建議優先使用 rAthena 官方指令, 以便確保最大的指令碼相容性.
	此處的 cap 實際上是 cap_value 的別名, 以便相容以前的部分指令碼.

返回值:
	要判斷的數值低於最小值則直接返回最小值, 超過最大值則直接返回最大值,
	如果要判斷的數值在兩者之間, 那麼原樣返回該數值

--------------------------------------------------------------

*mobremove <魔物的GID>;

根據 GID 移除一個魔物(只是移除, 不會讓魔物死亡)

魔物的GID:
	必填項, 比如使用 monster 指令碼指令後 $@mobid[] 陣列的內容

返回值:
	該指令無論執行成功與否, 都不會有返回值
	
--------------------------------------------------------------

*mesclear;

清空玩家與當前 NPC 的對話方塊內容, 清空後可以用 mes 重新給對話方塊填充內容

不推薦使用:
	rAthena 已經推出了功能完全一致的指令 clear;
	建議優先使用 rAthena 官方指令, 以便確保最大的指令碼相容性.
	此處的 mesclear 實際上是 clear 的別名, 以便相容以前的部分指令碼.

返回值:
	該指令無論執行成功與否, 都不會有返回值

--------------------------------------------------------------

*battleignore <開關標記>{,<角色編號>};

將指定的角色設定為魔物免戰狀態, 避免被魔物攻擊
魔物會無視此玩家的存在, 因此不會攻擊該玩家 (也可以叫無敵狀態)

不推薦使用:
	rAthena 已經推出了類似的指令碼指令解決方案.
	啟用無敵狀態等價於 rAthena 的官方指令用法: setpcblock PCBLOCK_IMMUNE, 1;
	建議優先使用 rAthena 官方指令, 以便確保最大的指令碼相容性.

開關標記:
	0 - 關閉免戰 (角色會被魔物看見)
	1 - 開啟免戰 (角色不會被魔物看見, 也不會被攻擊)

返回值:
	該指令無論執行成功與否, 都不會有返回值

--------------------------------------------------------------

*getinventorylist {<角色編號>{,<想查詢的資料型別>}};

用於查詢玩家揹包中的物品列表以及物品的全部詳情資訊, 該指令在 rAthena 的基礎上得到了改進.

想查詢的資料型別:
	有的使用者會把玩家的揹包擴充到一個比較大的值, 這時候如果還有一個指令碼頻繁呼叫 getinventorylist 的話,
	會導致程式預設填充幾乎所有物品資訊回來, 而往往很多資訊我們用不到, 這就會出現多餘的效能開銷.

	你可以透過該掩碼引數來控制指令內部給你填充指定的一個或多個陣列, 降低程式填充資料的工作量來降低卡頓.

	INV_ID              = 填充 @inventorylist_id[]                  - 道具編號
	INV_IDX             = 填充 @inventorylist_idx[]                 - 道具的揹包序號
	INV_AMOUNT          = 填充 @inventorylist_amount[]              - 道具的數量
	INV_EQUIP           = 填充 @inventorylist_equip[]               - 道具當前的裝備位置
	INV_REFINE          = 填充 @inventorylist_refine[]              - 道具的精煉值
	INV_IDENTIFY        = 填充 @inventorylist_identify[]            - 道具是否已鑑定 (0: 未鑑定; 1: 已鑑定)
	INV_ATTRIBUTE       = 填充 @inventorylist_attribute[]           - 道具的屬性

	INV_CARD            = 填充物品的插卡資訊陣列:
	                      @inventorylist_card1[]                   - 道具一號卡槽的卡片編號
	                      @inventorylist_card2[]                   - 道具二號卡槽的卡片編號
	                      @inventorylist_card3[]                   - 道具三號卡槽的卡片編號
	                      @inventorylist_card4[]                   - 道具四號卡槽的卡片編號

	INV_EXPIRE          = 填充 @inventorylist_expire[]              - 道具的過期時間戳 (0: 永不過期; 其他非零正整數表示 Unix 時間戳)
	INV_BOUND           = 填充 @inventorylist_bound[]               - 道具的繫結狀態
	INV_ENCHANTGRADE    = 填充 @inventorylist_enchantgrade[]        - 道具的附魔評級

	INV_OPTION          = 填充物品隨機屬性(Random Option)的資訊陣列:
	                      @inventorylist_option_id1[]
	                      @inventorylist_option_value1[]
	                      @inventorylist_option_parameter1[]
	                      @inventorylist_option_id2[]
	                      @inventorylist_option_value2[]
	                      @inventorylist_option_parameter2[]
	                      @inventorylist_option_id3[]
	                      @inventorylist_option_value3[]
	                      @inventorylist_option_parameter3[]
	                      @inventorylist_option_id4[]
	                      @inventorylist_option_value4[]
	                      @inventorylist_option_parameter4[]
	                      @inventorylist_option_id5[]
	                      @inventorylist_option_value5[]
	                      @inventorylist_option_parameter5[]

	INV_TRADABLE        = 填充 @inventorylist_tradable[]           - 道具是否可交易
	INV_FAVORITE        = 填充 @inventorylist_favorite[]           - 道具是否被標記為最喜歡的道具 (0: 未標記; 1: 已標記)
	INV_UID             = 填充 @inventorylist_uid$[]               - 道具的唯一編號 (字串型別的陣列, 末尾記得要帶 $ 符號)
	INV_EQUIPSWITCH     = 填充 @inventorylist_equipswitch[]        - 道具作為第二套快速切換裝備時的穿戴位置
	INV_ALL             = 填充以上全部陣列(預設值)

舉例說明:
	想查詢揹包中所有道具的資訊, 但只希望獲取揹包序號和數量:
	getinventorylist(getcharid(0), INV_IDX | INV_AMOUNT);

注意事項:
	若你指定了需要查詢的資料型別, 那麼未被查詢的資料陣列將不會被填充.

揹包序號:
	揹包序號每一次登入、每一次玩家在自己的揹包中增刪物品 (包括但不限: 
	存倉、存手推車、丟棄、購買和使用道具等操作) 都可能會導致揹包序號有變化.
	所以請注意在一段連續、玩家不可能會停下來做其他動作的指令碼中去使用“揹包序號”.
	否則, 只要在 getinventorylist 之後, 還給玩家或指令碼去進行道具的增刪,
	那麼 @inventorylist_idx[] 中的資料將立刻變得不再可靠.

--------------------------------------------------------------

*getcartlist {<角色編號>{,<想查詢的資料>}};

與 getinventorylist 類似, 但是查詢的是玩家的手推車中的物品資訊.
它的返回陣列與 getinventorylist 完全一致, 只是部分陣列的意義會發生變化:

- @inventorylist_favorite[]     - 該陣列無意義並且值固定為 0,
                                  因為手推車中的道具不能被標記為最喜歡的道具.
- @inventorylist_equipswitch[]  - 該陣列無意義並且值固定為 0,
                                  因為手推車中的道具不能被作為第二套快速切換裝備.
- @inventorylist_idx[]          - 道具的手推車序號

特別注意:
	這裡 @inventorylist_idx[] 讀取到的序號不再是道具的揹包序號,
	應該使用 getcartinfo 而不是 getinventoryinfo 來獲取物品的詳細資訊.
	
	玩家必須擁有手推車才能呼叫該指令, 否則會丟擲錯誤.
	
	若想規避終端提示無手推車錯誤, 
	可以在呼叫該指令之前使用 checkcart() 來確保玩家有手推車.

--------------------------------------------------------------

*getguildstoragelist {<角色編號>{,<想查詢的資料>}};

與 getinventorylist 類似, 但是查詢的是公會倉庫中的物品資訊.
它的返回陣列與 getinventorylist 完全一致, 只是部分陣列的意義會發生變化:

- @inventorylist_favorite[]     - 該陣列無意義並且值固定為 0,
                                  因為公會倉庫中的道具不能被標記為最喜歡的道具.
- @inventorylist_equipswitch[]  - 該陣列無意義並且值固定為 0,
                                  因為公會倉庫中的道具不能被作為第二套快速切換裝備.
- @inventorylist_idx[]          - 道具的公會倉庫序號

特別注意:
	這裡 @inventorylist_idx[] 讀取到的序號不再是道具的揹包序號,
	應該使用 getguildstorageinfo 而不是 getinventoryinfo 來獲取物品的詳細資訊.
	
	玩家必須加入擁有公會倉庫的公會才能呼叫該指令, 否則會丟擲錯誤.
	
	若想規避終端提示未加入公會以及沒有公會倉庫的錯誤,
	可以在呼叫該指令之前使用 getgdskilllv(getcharid(2), "GD_GUILD_STORAGE") > 0
	來確保玩家已加入有公會倉庫的公會.

--------------------------------------------------------------

*getstoragelist {<角色編號>{,<想查詢的資料>{,<倉庫編號>}}};

與 getinventorylist 類似, 但是查詢的是個人倉庫/擴充倉庫中的物品資訊.
它的返回陣列與 getinventorylist 完全一致, 只是部分陣列的意義會發生變化:

- @inventorylist_favorite[]     - 該陣列無意義並且值固定為 0,
                                  因為個人倉庫/擴充倉庫中的道具不能被標記為最喜歡的道具.
- @inventorylist_equipswitch[]  - 該陣列無意義並且值固定為 0,
                                  因為個人倉庫/擴充倉庫中的道具不能被作為第二套快速切換裝備.
- @inventorylist_idx[]          - 道具的個人倉庫/擴充倉庫序號

特別注意:
	這裡 @inventorylist_idx[] 讀取到的序號不再是道具的揹包序號,
	應該使用 getstorageinfo 而不是 getinventoryinfo 來獲取物品的詳細資訊.

倉庫編號:
	該指令支援獲取擴充倉庫的內容, 因此你需要在查詢時指定倉庫編號.

	0 - 個人倉庫 (每個玩家都會有的預設倉庫)
	X - 擴充倉庫 (其他非 0 的定義在 conf/inter_athena.yml 中的有效倉庫編號)

注意事項:
	該指令的引數順序和 getinventorylist、getcartlist、
	getguildstoragelist 有所差異, 使用的時候一定要注意, 不要被坑了.

--------------------------------------------------------------

*readparam(<引數程式碼>{,"<角色名稱>"})
*readparam(<引數程式碼>{,<角色編號>})

在 rAthena 原來的引數程式碼基礎上, 熊貓模擬器新增了以下幾個引數:

bAllStr - 返回角色的總 STR (用總 STR 減去 bStr 可得到面板中 STR 在加號右側的值)
bAllAgi - 返回角色的總 AGI (用總 AGI 減去 bAgi 可得到面板中 AGI 在加號右側的值)
bAllVit - 返回角色的總 VIT (用總 VIT 減去 bVit 可得到面板中 VIT 在加號右側的值)
bAllInt - 返回角色的總 INT (用總 INT 減去 bInt 可得到面板中 INT 在加號右側的值)
bAllDex - 返回角色的總 DEX (用總 DEX 減去 bDex 可得到面板中 DEX 在加號右側的值)
bAllLuk - 返回角色的總 LUK (用總 LUK 減去 bLuk 可得到面板中 LUK 在加號右側的值)

CartWeight - 手推車中的物品總重量 (脫下手推車時數值為 0)
MaxCartWeight - 手推車的最大負重量 (脫下手推車時數值為 0)

使用方法:
	dispbottom "總STR為 : " + readparam(bAllStr) + " (" + readparam(bStr) + " + " + (readparam(bAllStr) - readparam(bStr)) + ")";
	dispbottom "手推車當前負重情況: " + CartWeight + "/" + MaxCartWeight;

提示資訊:
	被 readparam 呼叫的有效 <引數程式碼> 可以直接當做常量使用

--------------------------------------------------------------

*gethotkey <快捷鍵位置編號>{,<要獲取的資料型別>};

獲取指定快捷鍵位置的資訊, 快捷鍵位置編號必須大於 0 小於 MAX_HOTKEYS.
MAX_HOTKEYS 是個常量, 在指令碼中可以直接使用以下方法來確認它的值:

	dispbottom "MAX_HOTKEYS = " + MAX_HOTKEYS;

要獲取的資料型別:
	可選引數, 若攜帶這個引數則函式的返回值會具備不同含義:
	0	- 獲取快捷鍵的型別
		> 若返回 0 表示該位置的快捷鍵上放的是一個物品
		> 若返回 1 表示該位置的快捷鍵上放的是一個技能
	1	- 獲取技能編號或物品編號
	2	- 獲取登記在快捷鍵上的技能等級

	若不攜帶 <要獲取的資料型別> 引數, 那麼指定的快捷鍵的資訊會被存放到以下角色變數:
	
	@hotkey_type	- 快捷鍵的型別 (為 0 表示物品, 為 1 表示技能)
	@hotkey_id		- 技能編號或物品編號
	@hotkey_lv		- 登記在快捷鍵上的技能等級

返回值:
	若攜帶 <要獲取的資料型別> 引數時, 發生錯誤將返回 -1, 成功則返回查詢的值;
	不攜帶 <要獲取的資料型別> 引數時, 發生錯誤將返回 -1, 成功則將資訊儲存到變數並返回 1

--------------------------------------------------------------

*sethotkey <快捷鍵位置編號>,<快捷鍵的型別>,<物品編號/技能編號>,<技能等級>;

設定玩家快捷鍵工具欄上的內容, 快捷鍵位置編號必須大於 0 小於 MAX_HOTKEYS.
MAX_HOTKEYS 是個常量, 在指令碼中可以直接使用以下方法來確認它的值:

	dispbottom "MAX_HOTKEYS = " + MAX_HOTKEYS;

快捷鍵的型別:
	0	- 這個快捷鍵想放置一個物品 (若使用該值, 則"技能等級"引數無意義, 請直接給"技能等級"引數傳 0 即可)
	1	- 這個快捷鍵想放置一個技能

物品編號/技能編號:
	根據您 <快捷鍵的型別> 的取值不同而擁有不同含義, 程式會校驗給定的物品編號或技能編號是否有效.

技能等級:
	只有當 <快捷鍵的型別> 的值為 1 時才有意義. 若是個物品的話, 這裡隨便傳什麼都會被預設為 0.

返回值:
	設定成功則返回 1, 設定失敗則返回 0

--------------------------------------------------------------

*showvend "<NPC名稱>",<是否顯示>{,"<招牌名稱>"};

使指定的 NPC 頭上可以顯示露天商店的招牌, 點選招牌可觸發與 NPC 的對話.

NPC名稱:
	你可以指定 NPC 的名稱, 或者用 strnpcinfo(0) 獲取當前 NPC 的名稱.

是否顯示:
	0 - 隱藏招牌 (當選擇隱藏招牌時, <招牌名稱> 引數可不傳遞)
	1 - 顯示招牌

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*viewequip <目標的角色編號|目標的賬號編號>{,<是否強制檢視>};

檢視指定線上角色的裝備面板資訊.

是否強制檢視:
	0	- 若目標角色禁止其他玩家檢視裝備, 那麼就不檢視 (對 GM 無影響)
	1	- 無視目標角色設定, 強制進行檢視

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*countitemidx <揹包序號>{,<角色編號>};
*countinventory <揹包序號>{,<角色編號>};

獲取指定揹包序號的道具在揹包中的數量. 

揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

返回值:
	操作成功則返回道具的數量, 操作失敗則返回 0

--------------------------------------------------------------

*delitemidx <揹包序號>{,<移除的數量>{,<角色編號>}};
*delinventory <揹包序號>{,<移除的數量>{,<角色編號>}};

移除指定揹包序號的道具, 支援指定移除數量以及目標角色編號. 
若被指定的道具已穿戴在目標角色身上, 那麼該裝備會被立刻脫下並移除.

揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

移除的數量:
	可選引數, 若不指定, 則表示你想刪除指定道具的全部.

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*identifyidx <揹包序號>{,<角色編號>};
*identifybyidx <揹包序號>{,<角色編號>};

鑑定指定揹包序號的道具.
只要揹包序號合法, 哪怕道具已經被鑑定過, 該函式也會返回 1.

揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*unequipidx <揹包序號>{,<角色編號>};
*unequipinventory <揹包序號>{,<角色編號>};

脫下指定揹包序號的道具.
只要揹包序號合法, 哪怕道具已被脫下, 該函式也會返回 1.
若指定的道具不是裝備, 那麼該函式將返回 0 (但不會報錯, 也不會警告).

揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*equipidx <揹包序號>{,<角色編號>};
*equipinventory <揹包序號>{,<角色編號>};

穿戴指定揹包序號的道具.
只要揹包序號合法, 哪怕道具已被穿戴, 該函式也會返回 1.
若指定的道具不是裝備, 那麼該函式將返回 0 (但不會報錯, 也不會警告).

揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

返回值:
	操作成功則返回 1, 操作失敗則返回 0


--------------------------------------------------------------

*itemexists <物品編號/"物品名稱">;
*existitem <物品編號/"物品名稱">;

確認物品資料庫中是否存在指定物品, 通常用於提高指令碼的健壯性.

物品編號/"物品名稱":
	多型別引數. 可以填寫數值型別的道具編號, 或者字串型別的道具名稱.
	推薦使用道具編號, 相較而言結果會更加準確.

注意事項:
	查詢時請避免填寫 [字串型別] 的道具編號, 
	因為這裡的引數只要是字串型別的, 都會走物品名稱判斷邏輯.

返回值:
	若物品指定的道具編號不存在於資料庫中則返回 0,
	若物品存在且 [可堆疊] 則返回 [正數] 物品編號, [不可堆疊] 則返回 [負數] 物品編號

--------------------------------------------------------------

*renttime <EQI裝備位置>,<增減的時間秒數>{,<角色編號>};
*setrenttime <EQI裝備位置>,<增減的時間秒數>{,<角色編號>};
*resume <EQI裝備位置>,<增減的時間秒數>{,<角色編號>};

增加/減少指定位置裝備的租賃時間.
如果要減少租賃時間的話, 第二個引數請使用負數.

EQI裝備位置:
	是指 EQI_* 開頭的位置常量, 可參考 doc/script_commands.txt

增減的時間秒數:
	若需要減少時間的話, 請使用負數.

注意事項:
	input 指令會將所有小於 0 的使用者輸入數值變成 0.
	若您希望由玩家透過 input 指令來指定要減少的秒數, 那麼需要加個負數符號.
	或者修改 conf/script_athena.conf 中 input_min_value 選項的值.

返回值:
	操作失敗返回 0, 非 0 的正數表示成功增減後新的剩餘時間秒數
	若指定位置沒有穿戴裝備, 或指定位置的裝備並非租賃道具, 函式都會返回 0

--------------------------------------------------------------

*getequipidx <EQI裝備位置>{,<角色編號>};

獲取指定位置裝備的揹包序號. 注意該函式返回 0 不代表失敗.

EQI裝備位置:
	EQI_COMPOUND_ON (-1)      - Item slot that calls this script (In context of item script)
	EQI_ACC_L (0)             - Accessory 1
	EQI_ACC_R (1)             - Accessory 2
	EQI_SHOES (2)             - Footgear (shoes, boots)
	EQI_GARMENT (3)           - Garment (mufflers, hoods, manteaux)
	EQI_HEAD_LOW (4)          - Lower Headgear (beards, some masks)
	EQI_HEAD_MID (5)          - Middle Headgear (masks, glasses)
	EQI_HEAD_TOP (6)          - Upper Headgear
	EQI_ARMOR (7)             - Armor (jackets, robes)
	EQI_HAND_L (8)            - Left hand (weapons, shields)
	EQI_HAND_R (9)            - Right hand (weapons)
	EQI_COSTUME_HEAD_TOP (10) - Upper Costume Headgear
	EQI_COSTUME_HEAD_MID (11) - Middle Costume Headgear
	EQI_COSTUME_HEAD_LOW (12) - Lower Costume Headgear
	EQI_COSTUME_GARMENT (13)  - Costume Garment
	EQI_AMMO (14)    		  - Arrow/Ammunition
	EQI_SHADOW_ARMOR (15)     - Shadow Armor
	EQI_SHADOW_WEAPON (16)    - Shadow Weapon
	EQI_SHADOW_SHIELD (17)    - Shadow Shield
	EQI_SHADOW_SHOES (18)     - Shadow Shoes
	EQI_SHADOW_ACC_R (19)     - Shadow Accessory 2
	EQI_SHADOW_ACC_L (20)     - Shadow Accessory 1


返回值:
	-1 - 在指定的EQI裝備位置找不到裝備
	-2 - 填寫的EQI裝備位置無效
	-3 - 指定的角色編號無效, 或者目標玩家不線上
	其他大於等於 0 的數值則表示成功, 返回值就是所查位置裝備的揹包序號

--------------------------------------------------------------

*statuscalc;
*status_calc;

根據角色目前的裝備、技能、狀態以及其他各種加成, 重新執行計算玩家的能力.

不推薦使用:
	rAthena 已經推出了功能完全一致的指令 recalculatestat;
	建議優先使用 rAthena 官方指令, 以便確保最大的指令碼相容性.
	此處的 statuscalc 和 status_calc 實際上是 recalculatestat 的別名, 以便相容以前的部分指令碼.

返回值:
	該指令無論執行成功與否, 都不會有返回值

--------------------------------------------------------------

*getequipexpiretick <EQI裝備位置>{,<角色編號>};
*isrental <EQI裝備位置>{,<角色編號>};

獲取指定位置裝備的租賃到期剩餘秒數.

EQI裝備位置:
	是指 EQI_* 開頭的位置常量, 可參考 doc/script_commands.txt

返回值:
	-1 - 在指定的EQI裝備位置找不到裝備
	-2 - 填寫的EQI裝備位置無效
	-3 - 指定的角色編號無效, 或者目標玩家不線上
	-4 - 剩餘秒數不合法 (比如: 道具早應該過期消失了, 但居然還在揹包裡)
	 0 - 此裝備不是租賃裝備, 永久有效
	其他大於 0 的數值則代表租賃到期的剩餘秒數

--------------------------------------------------------------

*updateinventory {<角色編號>};

該指令用於重新下發關聯玩家的揹包資料給客戶端.
涵蓋角色揹包每一個道具的每一個資訊, 請避免高頻呼叫或者迴圈呼叫.

--------------------------------------------------------------

*getinventoryinfo <道具的揹包序號>,<要檢視的資訊型別>{,<角色編號>};

查詢指定揹包序號的道具詳細資訊.

道具的揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

要檢視的資訊型別:
	0   - 物品編號
	1   - 堆疊數量
	2   - 裝備的穿戴位置
	3   - 精煉值
	4   - 是否已鑑定 (若已鑑定則返回 1, 未鑑定則返回 0)
	5   - 是否已損壞 (若已損壞則返回 1, 未損壞則返回 0)
	6   - 第一個卡槽的卡片編號
	7   - 第二個卡槽的卡片編號
	8   - 第三個卡槽的卡片編號
	9   - 第四個卡槽的卡片編號
	10  - 過期時間 (Unix時間戳, 0 表示永不過期)
	11  - 唯一編號 (unique_id)
	
	12  - 第一個隨機屬性的編號 (ROA_ID)
	13  - 第二個隨機屬性的編號 (ROA_ID)
	14  - 第三個隨機屬性的編號 (ROA_ID)
	15  - 第四個隨機屬性的編號 (ROA_ID)
	16  - 第五個隨機屬性的編號 (ROA_ID)
	
	17  - 第一個隨機屬性的值 (ROA_VALUE)
	18  - 第二個隨機屬性的值 (ROA_VALUE)
	19  - 第三個隨機屬性的值 (ROA_VALUE)
	20  - 第四個隨機屬性的值 (ROA_VALUE)
	21  - 第五個隨機屬性的值 (ROA_VALUE)
	
	22  - 第一個隨機屬性的引數 (ROA_PARAM)
	23  - 第二個隨機屬性的引數 (ROA_PARAM)
	24  - 第三個隨機屬性的引數 (ROA_PARAM)
	25  - 第四個隨機屬性的引數 (ROA_PARAM)
	26  - 第五個隨機屬性的引數 (ROA_PARAM)

	27  - 道具的繫結型別
	28  - 道具的附魔評級 (Grade Level)
	29  - 道具作為第二套快速切換裝備時的穿戴位置
	30  - 道具是否被標記為最喜歡的道具 (0: 未標記; 1: 已標記)

裝備的穿戴位置:
	如果為 0 則表示還沒穿戴在身上, 位置請參考 EQP_* 開頭的常量
	查詢的資訊型別 2 和 29 都是 EQP_* 開頭的常量.

道具的繫結型別:
	Bound_None      -   沒有繫結 (與 0 等價, 但更推薦用常量)
	Bound_Account   -   繫結賬號的道具, 可放個人倉庫, 全賬號共享
	Bound_Guild     -   繫結公會的道具, 可放公會倉庫與他人共享, 擁有物品的人離開公會後物品消失
	Bound_Party     -   繫結隊伍的道具, 離開隊伍後消失
	Bound_Char      -   繫結角色的道具, 不能放個人倉庫

注意事項:
	從 v1.0.6 版本開始,
	若查詢的資訊型別是 11 (裝備的唯一編號),
	那麼返回值既可以存放在數值型變數, 也可以存放在字串型變數.

返回值:
	獲取失敗則返回 -1, 獲取成功則返回你所查詢的資訊

--------------------------------------------------------------

*getcartinfo <道具的手推車序號>,<要檢視的資訊型別>{,<角色編號>};

查詢指定手推車序號的道具詳細資訊.

道具的手推車序號:
	可以透過 getcartlist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

要檢視的資訊型別:
	請參考 getinventoryinfo 的引數定義, 它們完全一致.
	
	以下資訊型別, 對於手推車道具沒有意義:

		29 - 道具作為第二套快速切換裝備時的穿戴位置
		     因為手推車中的道具不能作為第二套快速切換裝備
		30 - 道具是否被標記為最喜歡的道具
		     因為手推車中的道具不能被標記為最喜歡的道具

返回值:
	獲取失敗則返回 -1, 獲取成功則返回你所查詢的資訊

--------------------------------------------------------------

*getguildstorageinfo <道具的公會倉庫序號>,<要檢視的資訊型別>{,<角色編號>};

查詢指定公會倉庫序號的道具詳細資訊.

道具的公會倉庫序號:
	可以透過 getguildstoragelist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

要檢視的資訊型別:
	請參考 getinventoryinfo 的引數定義, 它們完全一致.
	
	以下資訊型別, 對於公會倉庫道具沒有意義:

		29 - 道具作為第二套快速切換裝備時的穿戴位置
		     因為公會倉庫中的道具不能作為第二套快速切換裝備
		30 - 道具是否被標記為最喜歡的道具
		     因為公會倉庫中的道具不能被標記為最喜歡的道具

返回值:
	獲取失敗則返回 -1, 獲取成功則返回你所查詢的資訊

--------------------------------------------------------------

*getstorageinfo <道具的個人倉庫/擴充倉庫序號>,<要檢視的資訊型別>{{,<倉庫編號>},<角色編號>};

查詢指定個人倉庫/擴充倉庫序號的道具詳細資訊.

道具的個人倉庫/擴充倉庫序號:
	可以透過 getstoragelist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

要檢視的資訊型別:
	請參考 getinventoryinfo 的引數定義, 它們完全一致.
	
	以下資訊型別, 對於個人倉庫/擴充倉庫道具沒有意義:

		29 - 道具作為第二套快速切換裝備時的穿戴位置
		     因為個人倉庫/擴充倉庫中的道具不能作為第二套快速切換裝備
		30 - 道具是否被標記為最喜歡的道具
		     因為個人倉庫/擴充倉庫中的道具不能被標記為最喜歡的道具

倉庫編號:
	該指令支援獲取擴充倉庫的內容, 因此你需要在查詢時指定倉庫編號.

	0 - 個人倉庫 (每個玩家都會有的預設倉庫)
	X - 擴充倉庫 (其他非 0 的定義在 conf/inter_athena.yml 中的有效倉庫編號)

返回值:
	獲取失敗則返回 -1, 獲取成功則返回你所查詢的資訊

--------------------------------------------------------------

*getstoragestate <查詢的資訊型別>{,<倉庫編號>{,<角色編號>}};

查詢倉庫的容量和資料儲存狀態等相關資訊

查詢的資訊型別:
	STORE_TOTAL   - 倉庫最大容量 (格子數)
	STORE_USED    - 倉庫已用容量 (格子數)
	STORE_LEFT    - 倉庫剩餘容量 (格子數)

	STORE_OPENING - 當前是否處於開啟狀態

	                1 - 當前倉庫處於開啟狀態
	                0 - 當前倉庫處於關閉狀態

	STORE_DIRTY   - 當前是否存在未儲存的資料

	                1 = 有未儲存的資料
	                0 = 全部資料已被儲存

倉庫編號:
	該指令支援獲取擴充倉庫的內容, 因此你需要在查詢時指定倉庫編號.

	0 - 個人倉庫 (每個玩家都會有的預設倉庫)
	X - 擴充倉庫 (其他非 0 的定義在 conf/inter_athena.yml 中的有效倉庫編號)

返回值:
	獲取失敗則返回 -1, 獲取成功則返回你所查詢的資訊

--------------------------------------------------------------

*isopenstorage {<角色編號>};

查詢指定玩家當前是否開啟了倉庫

返回值:
	-1 - 找不到指定的角色
	0  - 沒有開啟倉庫
	1  - 開啟了個人倉庫
	2  - 開啟了公會倉庫
	3  - 開啟了拓展倉庫
	     使用 @premium_stor_id 可讀取當前開啟的拓展倉庫編號

--------------------------------------------------------------

*setinventoryinfo <道具的揹包序號>,<要設定的資訊型別>,<值>{{,<標記位>},<角色編號>};

設定指定揹包序號道具的詳細資訊.
值得注意的是, 這裡修改的主要是每個玩家各有不同的那些道具的屬性資訊,
例如: 道具插入的卡片, 道具的精煉值等等

道具的揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

要設定的資訊型別:
	3   - 精煉值
	4   - 是否已鑑定 (若已鑑定則返回 1, 未鑑定則返回 0)
	5   - 是否已損壞 (若已損壞則返回 1, 未損壞則返回 0)
	6   - 第一個卡槽的卡片編號
	7   - 第二個卡槽的卡片編號
	8   - 第三個卡槽的卡片編號
	9   - 第四個卡槽的卡片編號
	10  - 過期時間 (Unix時間戳, 0 表示永不過期)
	11  - 唯一編號 (unique_id)
	
	12  - 第一個隨機屬性編號 (ROA_ID)
	13  - 第二個隨機屬性編號 (ROA_ID)
	14  - 第三個隨機屬性編號 (ROA_ID)
	15  - 第四個隨機屬性編號 (ROA_ID)
	16  - 第五個隨機屬性編號 (ROA_ID)
	
	17  - 第一個隨機屬性的值 (ROA_VALUE)
	18  - 第二個隨機屬性的值 (ROA_VALUE)
	19  - 第三個隨機屬性的值 (ROA_VALUE)
	20  - 第四個隨機屬性的值 (ROA_VALUE)
	21  - 第五個隨機屬性的值 (ROA_VALUE)
	
	22  - 第一個隨機屬性的引數 (ROA_PARAM)
	23  - 第二個隨機屬性的引數 (ROA_PARAM)
	24  - 第三個隨機屬性的引數 (ROA_PARAM)
	25  - 第四個隨機屬性的引數 (ROA_PARAM)
	26  - 第五個隨機屬性的引數 (ROA_PARAM)

	27  - 道具的繫結型別
	28  - 道具的附魔評級 (Grade Level)
	29  - 道具作為第二套快速切換裝備時的穿戴位置
	30  - 道具是否被標記為最喜歡的道具 (0: 未標記; 1: 已標記)

卡片編號:
	若將卡片編號設定為 0 則視為刪除卡片.
	需要注意的是, 卡片將會被憑空移除, 不會留下任何日誌記錄.

隨機屬性編號:
	此處的編號是 item_randomopt_db.yml 資料庫中的 VAR_* 開頭的常量,
	但需要注意的是從 yml 檔案中獲得的常量需要新增 RDMOPT_ 字首才是最後生效的最終常量名,
	例如: VAR_MAXHPAMOUNT 最終常量名是 RDMOPT_VAR_MAXHPAMOUNT.
	
	若將此處的編號設定為 0, 那麼將會同時清空對應的 ROA_VALUE 和 ROA_PARAM 選項的值.

道具的繫結型別:
	Bound_None      -   沒有繫結 (與 0 等價, 但更推薦用常量)
	Bound_Account   -   繫結賬號的道具, 可放個人倉庫, 全賬號共享
	Bound_Guild     -   繫結公會的道具, 可放公會倉庫與他人共享, 擁有物品的人離開公會後物品消失
	Bound_Party     -   繫結隊伍的道具, 離開隊伍後消失
	Bound_Char      -   繫結角色的道具, 不能放個人倉庫

過期時間:
	當您要設定的型別是 10 (過期時間)時, 一定要注意這是個Unix時間戳.
	
	若將值設為 60 秒, 那麼道具會因為已過期被立刻刪掉:
		setinventoryinfo(<揹包序號>, 10, 60);	// 錯誤

	延長道具 60 秒有效期的正確寫法是:
		setinventoryinfo(<揹包序號>, 10, gettimetick(2) + 60);	// 正確

標記位:
	每次呼叫該指令時會呼叫按需重算角色屬性, 且必定重新傳送完整揹包資料給客戶端
	但如果因為你需要迴圈處理揹包中的全部道具, 那麼你有 100 個道具, 
	伺服器就需要把 100 個道具資訊下發 100 次給客戶端, 這是非常低效且不合理的.
	
	原則上儘量避免大量迴圈呼叫 setinventoryinfo 指令,
	但如果無法避免, 那麼可以考慮透過傳遞特殊標記位, 來在迴圈過程中抑制能力重算
	或者揹包資料的重新整理行為, 在迴圈結束後再觸發一次相關行為.
	
		&1 : 跳過角色能力重算
		&2 : 跳過全量重新整理角色的揹包資料
		&4 : 忽略卡片插入合理性的校驗 (插入的道具型別必須是卡片, 卡片位置和裝備位置符合)
		&8 : 插入卡片無需寫入 picklog 記錄 (憑空生成)
	
	若標記位設定為 0 則表示維持預設行為.
	
	--------
	
	提示資訊: 
	
	- 使用 &1 標記位的迴圈結束後, 可以使用 recalculatestat(); 觸發角色能力重算
	- 使用 &2 標記位的迴圈結束後, 可以使用 updateinventory(); 重現傳送最新揹包資料給客戶端

返回值:
	-1 - 設定失敗, 插入的卡片不合法
	 0 - 設定失敗
	 1 - 設定成功

--------------------------------------------------------------

*statuscheck <狀態編號>{,<遊戲單位編號>};
*sc_check <狀態編號>{,<遊戲單位編號>};

該指令用於判斷狀態是否存在, 並取得相關的狀態引數.

不推薦使用:
	rAthena 已經推出了功能近似的指令 getstatus;
	建議優先使用 rAthena 官方指令, 以便確保最大的指令碼相容性.

狀態編號:
	每一個增益或者減益狀態都有一個編號, 指令碼中一般用常量表示.
	比如負重超過 50% 的狀態編號是: SC_WEIGHT50
	這部分的常量定義可以在: src/map/status.hpp 中的 sc_type 定義中找到.

遊戲單位編號:
	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的物件只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>

資訊透過變數返回:
	當返回值為 1 的時候, 可以透過以下變數來讀取狀態的引數:

	@sc_val1		狀態的第 1 個引數值 (如果是技能對應的狀態的話, 往往這個引數都是技能等級)
	@sc_val2		狀態的第 2 個引數值
	@sc_val3		狀態的第 3 個引數值
	@sc_val4		狀態的第 4 個引數值
	@sc_tickleft	狀態的剩餘時間 (單位為毫秒, 若為 -1 表示永久有效)

注意事項:
	從 v1.0.7 版本開始 @sc_tickleft 的上限已經[不會再被限制]到 2147483647 毫秒.

返回值:
	獲取成功則返回 1, 角色沒有該狀態則返回 0, 其他錯誤返回 -1

--------------------------------------------------------------

*renttimeidx <揹包序號>,<增減的時間秒數>{,<角色編號>};

增加/減少指定揹包序號道具的租賃時間.
如果要減少租賃時間的話, 第二個引數請使用負數.

該指令與 renttime 近似, 只是 renttime 操作的是某個已穿戴的裝備,
而 renttimeidx 指令可以透過揹包序號來指定要調整的物品.

揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

增減的時間秒數:
	若需要減少時間的話, 請使用負數.

注意事項:
	input 指令會將所有小於 0 的使用者輸入數值變成 0.
	若您希望由玩家透過 input 指令來指定要減少的秒數, 那麼需要加個負數符號.
	或者修改 conf/script_athena.conf 中 input_min_value 選項的值.

返回值:
	操作失敗返回 0, 非 0 的正數表示成功增減後新的剩餘時間秒數
	若指定位置沒有穿戴裝備, 或指定位置的裝備並非租賃道具, 函式都會返回 0

--------------------------------------------------------------

*party_leave {<角色編號>};

使當前角色或指定角色退出隊伍.

不推薦使用:
	rAthena 已經推出了功能近似的指令 party_delmember;
	建議優先使用 rAthena 官方指令, 以便確保最大的指令碼相容性.

角色編號:
	若不指定角色編號, 那麼將會使執行該指令的玩家退出隊伍.

返回值:
	若指定的角色不線上或不在隊伍中則返回 0,
	若角色成功退出隊伍則返回 1

--------------------------------------------------------------

*script4each <"{指令碼}">,<指令碼執行範圍>{,<動態引數>...};
*script4eachmob <"{指令碼}">,<指令碼執行範圍>{,<動態引數>...};
*script4eachnpc <"{指令碼}">,<指令碼執行範圍>{,<動態引數>...};

對指定範圍的單位執行相同的一段指令碼.
若使用 script4each 指令, 則執行 <指令碼> 的玩家將會成為其預設關聯玩家.

指令碼的執行範圍:
	0 - 全服單位								例: script4each "{<指令碼>}",0;
	1 - 指定地圖上的全部單位					例: script4each "{<指令碼>}",1,<"地圖名稱">;
	2 - 以地圖某個點為中心半徑距離內的單位		例: script4each "{<指令碼>}",2,<"地圖名稱">,<中心座標x>,<中心座標y>,<範圍>;
	3 - 指定玩家所在的隊伍中的全部隊伍成員		例: script4each "{<指令碼>}",3,<角色編號>;
	4 - 指定玩家所在的公會中的全部公會成員		例: script4each "{<指令碼>}",4,<角色編號>;
	5 - 指定區域內的全部單位					例: script4each "{<指令碼>}",5,<"地圖名稱">,<座標x0>,<座標y0>,<座標x1>,<座標y1>;
	6 - 指定隊伍中的全部隊伍成員				例: script4each "{<指令碼>}",6,<隊伍編號>;
	7 - 指定公會中的全部公會成員				例: script4each "{<指令碼>}",7,<公會編號>;
	
	其中 3,4,6,7 僅支援被 script4each 使用, 無法對 script4eachmob 和 script4eachnpc 生效.

可無視外層大括號:
	從 Pandas v1.0.1 版本開始, {<指令碼>} 引數中最外層的大括號可以被忽略.

	例如, 以前必須加外層大括號, 否則會報錯:

		script4each "{ getitem 501, 10; }", 0;

	現在, 可以直接忽略最外層大括號, 簡寫變成:

		script4each "getitem 501, 10;", 0;

透過變數返回 GID:
	當 script4each 系列指令即將在某個單位身上執行指令碼之前, 會將該單位的 GID 儲存到 $@gid
	透過 $@gid 變數儲存的內容, 就能利用 unit* 系列指令來操作目標單位.
	
	例如, 以下程式碼會讓全服魔物立刻說出自己的名字:

		script4eachmob "{ unittalk $@gid, getunitname($@gid); }", 0;

雙引號轉義: 
	如果 <指令碼> 引數中有使用到雙引號的話, 需要在雙引號的左側使用 \ 來進行轉義.
	
	假設我們希望讓全服玩家執行這樣一段指令碼: 
	
		announce "角色名稱: " + strcharinfo(0) + " | 角色編號: " + getcharid(0), 0;
	
	那麼上述指令碼在使用 script4each 系列指令來執行的時候, <指令碼> 引數內的雙引號都需要加 \ 來轉義,
	轉義操作很簡單, 直接將 " 替換成 \" 即可, 最後呼叫 script4each 時用法如下:
	
		script4each "{ announce \"角色名稱: \" + strcharinfo(0) + \" | 角色編號: \" + getcharid(0), 0; }", 0;
	
字串變數拼接特別注意:	
	角色名預設也允許玩家使用雙引號, 在這種情況下當您使用 strcharinfo(0) 作為指令碼的一部分,
	或者引用其他字串變數作為指令碼的一部分但其內容中可能包含雙引號的時候, 也需要對這些字串變數的內容進行雙引號轉義.
	
	比較推薦的方法是自己包裝一個轉義函式, 來將 " 替換成 \", 參考程式碼如下:
	
		function	script	esc_double_quotation	{
			.@text$ = getarg(0, "");
			.@text$ = replacestr(.@text$, "\"", "\\\"");
			return .@text$;
		}
	
	然後在拼接 script4each 用於執行的指令碼時, 參與拼接的字串變數都套上它:
	
		script4each "{ announce \"角色名稱: \" + esc_double_quotation(strcharinfo(0)) + \" | 角色編號: \" + getcharid(0), 0; }", 0;
	
	這樣就是比較完備和嚴謹的做法了, 哪怕角色名帶雙引號也不會導致指令碼解析失敗.
	之所以不推薦使用 escape_sql 指令來進行轉義, 是因為它除了轉義雙引號還會處理單引號等其他符號, 而我們只關心雙引號.

支援呼叫事件標籤:
	從 Pandas v1.0.2 版本開始, {<指令碼>} 引數支援直接呼叫指定的 NPCNAME::EVENT 事件標籤.
	
	有時我們的 {<指令碼>} 引數需要寫入大量複雜的條件判斷, 若只寫成一行,
	那麼可讀性會很差, 大量的轉義操作都過於繁瑣.
	
	現在開始你可以將複雜的指令碼邏輯直接定義到某個 NPCNAME::EVENT 事件標籤中,
	並在 script4each 系列指令中透過 {<指令碼>} 引數直接呼叫, 方法如下:
	
	-	script	elabel_demo	-1,{
	end;
	OnLoveTest:
		unittalk $@gid, "我的名稱是: " + getunitname($@gid);
	end;
	}
	
	prontera,150,150,4	script	elabel_test	123,{
		// 使全服玩家執行 elabel_demo::OnLoveTest 事件標籤對應的指令碼
		script4each "elabel_demo::OnLoveTest",0;
	}

注意事項:
	請注意給該系列指令指定 <指令碼的執行範圍> 使盡量合理.
	例如服務端預設情況下載入的 NPC 指令碼, 總共就包含 2 萬個 NPC 單位,
	若頻繁使用 script4eachnpc 且將 <指令碼的執行範圍> 設定為 0 的話, {<指令碼>} 就會在 2 萬個 NPC 上頻繁執行.
	使用不當的話, 會比較容易導致伺服器出現卡頓的現象.
	
	若使用 NPCNAME::EVENT 方式呼叫 script4each 系列指令的話, 雙引號內 NPCNAME::EVENT 的左右請不要加空格:

		script4each "elabel_demo::OnLoveTest",0;	// 正確示例
		script4each " elabel_demo::OnLoveTest",0;	// 錯誤示例: elabel_demo 左側有個空格
		script4each "elabel_demo::OnLoveTest ",0;	// 錯誤示例: OnLoveTest 右側有個空格

	否則可能會找不到對應的 NPCNAME::EVENT, 從而導致引擎將 {<指令碼>} 的內容當做常規指令碼進行語法解析, 最終報錯.

返回值:
	該指令無論成功失敗, 都不會有返回值

--------------------------------------------------------------

*searcharray <陣列變數>,<要查詢的字串或數值>;

查詢陣列中第一次出現待查詢內容的索引序號, 使用它來搜尋陣列內容很方便.

不推薦使用:
	rAthena 已經推出了功能近似的指令 inarray;
	建議優先使用 rAthena 官方指令, 以便確保最大的指令碼相容性.

返回值:
	若查不到結果則返回 -1, 否則返回大於等於 0 的索引序號

--------------------------------------------------------------

*getsameipinfo {<"IP地址">{,<"地圖名">}};

獲得某個指定 IP 線上的玩家資訊.
若不指定任何引數, 則預設查詢當前指令碼關聯角色的 IP 地址.

IP地址:
	可選引數, 若需要指定的話請填寫標準的 4 段式 IP 地址,
	例如: getsameipinfo "114.114.114.114"

地圖名:
	可選引數, 若想指定此引數則必須先指定<"IP地址">
	地圖名不需要新增 .gat 字尾

資訊透過變數返回:
	@sameip_aid[]		該 IP 線上的玩家賬號編號陣列 - 數值型陣列
	@sameip_cid[]		該 IP 線上的玩家角色編號陣列 - 數值型陣列
	@sameip_name$[]		該 IP 線上的玩家角色名稱陣列 - 字元型陣列

返回值及 @sameip_amount 變數都會賦予目前使用指定IP登入的玩家個數.

提示資訊:
	官方自帶的 getcharip 指令碼指令可以獲得某個玩家的 IP 地址, 
	配合這個指令就能知道對方相同 IP 下有幾個角色線上.

返回值:
	出錯返回 -1, 其他含 0 正整數表示查到的此 IP 的線上玩家數

示例程式碼:
	// 查詢全服範圍內, 和當前角色 IP 相同的玩家資訊和數量
	getsameipinfo(getcharip());
	
	// 查詢普隆德拉地圖中, 和當前角色 IP 相同的玩家資訊和數量
	getsameipinfo(getcharip(), "prontera");
	
	// 查詢和當前角色相同的地圖中, 和當前角色 IP 相同的玩家資訊和數量
	getsameipinfo(getcharip(), strcharinfo(3));

--------------------------------------------------------------

*logout <登出理由>{,"<角色名稱>"|<賬號編號>|<角色編號>};

使指定的角色立刻登出遊戲(踢下線), 此處的"登出理由"只能做參考,
不同的理由編號會讓客戶端給玩家顯示不同的 msgstringtable 提示文字:

登出理由:
	0 = BAN_UNFAIR
	1 = 伺服器已關閉 -> MsgStringTable[4]
	2 = ID already logged in -> MsgStringTable[5]
	3 = 連線超時 / 網路延遲不穩定 -> MsgStringTable[241]
	4 = 伺服器已經滿員 -> MsgStringTable[264]
	5 = underaged -> MsgStringTable[305]
	8 = Server sill recognizes last connection -> MsgStringTable[441]
	9 = too many connections from this ip -> MsgStringTable[529]
	10 = out of available time paid for -> MsgStringTable[530]
	11 = BAN_PAY_SUSPEND
	12 = BAN_PAY_CHANGE
	13 = BAN_PAY_WRONGIP
	14 = BAN_PAY_PNGAMEROOM
	15 = 被 GM 踢下線 -> if( servicetype == taiwan ) MsgStringTable[579]
	16 = BAN_JAPAN_REFUSE1
	17 = BAN_JAPAN_REFUSE2
	18 = BAN_INFORMATION_REMAINED_ANOTHER_ACCOUNT
	100 = BAN_PC_IP_UNFAIR
	101 = BAN_PC_IP_COUNT_ALL
	102 = BAN_PC_IP_COUNT
	103 = BAN_GRAVITY_MEM_AGREE
	104 = BAN_GAME_MEM_AGREE
	105 = BAN_HAN_VALID
	106 = BAN_PC_IP_LIMIT_ACCESS
	107 = BAN_OVER_CHARACTER_LIST
	108 = BAN_IP_BLOCK
	109 = BAN_INVALID_PWD_CNT
	110 = BAN_NOT_ALLOWED_JOBCLASS
	111 = 與伺服器斷開連線 -> MsgStringTable[3]

返回值:
	該指令無論成功失敗, 都不會有返回值

--------------------------------------------------------------

*warppartyrevive "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>",<range x>,<range y>};
*warpparty2 "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>",<range x>,<range y>};

該指令的用法與 warpparty 完全一樣, 都是將指定隊伍全員傳送到指定目的地.

區別在於: 
	warpparty 對已經死亡的隊友則無效 (死亡的隊友會被留在原地),
	warppartyrevive 對已經死亡的隊友有效 (隊友會被立刻復活, 並一起被傳送走).

返回值:
	該指令無論成功失敗, 都不會有返回值

--------------------------------------------------------------

*getareagid <返回陣列>,<搜尋範圍>{,<動態引數>...};

獲取指定範圍內特定型別單位的全部 GID, 並返回到指定的陣列中.

返回陣列:
	必填項, 需要指定一個用於返回GID的數值型陣列
	若給定的是角色相關變數 (比如角色變數級的陣列), 那麼指令碼必須關聯到某個玩家
	若給定的是系統相關變數 (比如地圖伺服器的陣列), 那麼指令碼無需關聯到某個玩家

搜尋範圍:
	指定地圖上的全部玩家				- getareagid <返回陣列>,0,<想搜尋的單位型別>,<"地圖名稱">;
	以地圖某個點為中心半徑距離內的玩家	- getareagid <返回陣列>,1,<想搜尋的單位型別>,<"地圖名稱">,<中心座標x>,<中心座標y>,<範圍>;
	指定區域內的全部玩家				- getareagid <返回陣列>,2,<想搜尋的單位型別>,<"地圖名稱">,<座標x0>,<座標y0>,<座標x1>,<座標y1>;

想搜尋的單位型別:
	BL_PC		- 玩家角色單位
	BL_MOB		- 魔物單位
	BL_PET		- 寵物單位
	BL_HOM		- 人工生命體單位
	BL_MER		- 傭兵單位
	BL_ITEM		- 物品單位
	BL_SKILL	- 技能單位
	BL_NPC		- NPC單位
	BL_CHAT		- 聊天室單位
	BL_ELEM		- 元素精靈單位
	BL_ALL		- 全部單位型別

地圖名稱:
	指定的地圖名稱, 比如 "prontera" 表示普隆德拉
	地圖名稱可以設定為 "this", 表示獲取當前指令碼關聯玩家所在的地圖

注意事項:
	該指令被重新設計過, 引數相比 rAthenaCN 老版本有所不同, 使用時需要注意.

返回值:
	操作失敗返回 -1, 其他含 0 正整數表示搜尋到的 GID 數量

--------------------------------------------------------------

*getiteminfo(<物品編號>,<查詢的資訊型別>{,<用於返回附加資料的陣列>})

在 rAthena 原來的引數程式碼基礎上, 熊貓模擬器新增了一些查詢資訊型別.

注意事項:
	從 Pandas v1.0.1 版本開始, -5 型別的返回值不再直接返回支援捕捉的魔物編號

查詢的資訊型別 (注意: 傳入引數是負數):
	-1	-	是否可精煉
	-2	-	交易限制掩碼
	-3	-	避免物品被玩家主動使用而消耗
	-4	-	避免物品被作為發動技能的必要道具而消耗		
	-5	-	是否為寵物捕捉道具
	-6	-	是否在其使用指令碼中呼叫了 callfunc 指令
	-7	-	返回物品的 "使用指令碼" 字串
	-8	-	返回物品的 "裝備指令碼" 字串
	-9	-	返回物品的 "卸裝指令碼" 字串

返回值:
	-1	-	返回 1 表示可以精煉, 0 表示不能精煉
	-2	-	返回該物品在 item_trade 資料庫中第二列定義的值
	-3	-	返回 1 表示可以避免消耗, 0 表示不避免消耗
	-4	-	返回 1 表示可以避免消耗, 0 表示不避免消耗
	-5	-	返回 1 表示這是一個寵物捕捉道具 (<用於返回附加資料的陣列> 將返回支援捕捉的魔物編號), 0 表示不是
	-6	-	返回 0 表示沒有呼叫 callfunc 函式, 返回 1 表示呼叫了 callfunc 函式
	-7	-	返回字串內容, 包含物品的 "使用指令碼" 字串
	-8	-	返回字串內容, 包含物品的 "裝備指令碼" 字串
	-9	-	返回字串內容, 包含物品的 "卸裝指令碼" 字串
	
	其中 -5 和 -6 若返回 -2 則表示未編譯此功能
	其中 -7 到 -9 若返回 UnCompiled 字串則表示未編譯此功能
	以上全部資訊型別, 若返回 -1 表示這個物品編號是不存在或無效的.

用於返回附加資料的陣列:
	目前僅 -5 型別會使用到, 如果查詢 -5 型別的時候指定 <用於返回附加資料的陣列>
	那麼該道具支援捕捉的魔物編號將會填充到這個陣列中 (注意: 只能使用數值型陣列).

示例程式碼:
	prontera,150,150,5	script	查詢抓寵道具	123,{
		mes "[查詢抓寵道具]";
		mes "請輸入要查詢的道具編號.";
		next;
		
		input .@nameid;
		cleararray .@taming_mobid, 0, getarraysize(.@taming_mobid);
		.@result = getiteminfo(.@nameid, -5, .@taming_mobid);
		
		if (.@result == -1) {
			mes "[查詢抓寵道具]";
			mes "道具編號: " + .@nameid;
			mes "查詢結論: 道具編號不存在或無效";
		}
		else if (.@result == -2) {
			mes "[查詢抓寵道具]";
			mes "道具編號: " + .@nameid;
			mes "查詢結論: 此功能未編譯到程式碼中";
		}
		else if (.@result == 1) {
			mes "[查詢抓寵道具]";
			mes "道具編號: " + .@nameid;
			mes "查詢結論: 這是抓寵道具, 能抓:";
			mes "==========";
			for (.@i = 0; .@i < getarraysize(.@taming_mobid); .@i++) {
				mes "> 魔物編號: " + .@taming_mobid[.@i];
			}
		}
		else {
			mes "[查詢抓寵道具]";
			mes "道具編號: " + .@nameid;
			mes "查詢結論: 這應該不是抓寵道具";
		}
		close;
	}

--------------------------------------------------------------

*processhalt {<是否設定中斷>};

該指令只能在事件處理指令碼中使用.
設定中斷可以打斷本次事件指令碼結束後的原始碼後續邏輯.

每個事件的原始碼後續邏輯各有不同, 且只能用於部分事件, 詳情請參考事件說明文件.

是否設定中斷:
	可選引數, 填寫 0 表示取消中斷, 填寫 1 表示設定中斷.
	若不攜帶該引數則預設為: 1 - 設定中斷

返回值:
	該指令無論成功失敗, 都不會有返回值

--------------------------------------------------------------

*settrigger <事件的常量名稱>,<觸發行為>;

使用該指令可以設定某個事件或過濾器的觸發行為

事件的常量名稱:
	每個事件或過濾器在程式碼中都有自己的常量名稱, 對照如下:
	
	NPCE_LOGIN				-	OnPCLoginEvent
	NPCE_LOGOUT				-	OnPCLogoutEvent
	NPCE_LOADMAP			-	OnPCLoadMapEvent
	NPCE_BASELVUP			-	OnPCBaseLvUpEvent
	NPCE_JOBLVUP			-	OnPCJobLvUpEvent
	NPCE_DIE				-	OnPCDieEvent
	NPCE_KILLPC				-	OnPCKillEvent
	NPCE_KILLNPC			-	OnNPCKillEvent
	NPCE_STATCALC			-	OnPCStatCalcEvent
	
	NPCF_IDENTIFY			-	OnPCIdentifyFilter
	NPCF_ENTERCHAT			-	OnPCInChatroomFilter
	NPCF_INSERT_CARD		-	OnPCInsertCardFilter
	NPCF_USE_ITEM			-	OnPCUseItemFilter
	NPCF_USE_SKILL			-	OnPCUseSkillFilter
	NPCF_ROULETTE_OPEN		-	OnPCOpenRouletteFilter
	NPCF_VIEW_EQUIP			-	OnPCViewEquipFilter
	NPCF_EQUIP				-	OnPCEquipFilter
	NPCF_UNEQUIP			-	OnPCUnequipFilter
	NPCF_CHANGETITLE		-	OnPCChangeTitleFilter
	NPCF_SC_START			-	OnPCBuffStartFilter
	
	NPCE_KILLMVP			-	OnPCKillMvpEvent
	NPCE_IDENTIFY			-	OnPCIdentifyEvent
	NPCE_INSERT_CARD		-	OnPCInsertCardEvent
	NPCE_USE_ITEM			-	OnPCUseItemEvent
	NPCE_USE_SKILL			-	OnPCUseSkillEvent
	NPCE_EQUIP				-	OnPCEquipEvent
	NPCE_UNEQUIP			-	OnPCUnequipEvent

	NPCX_SC_START			-	OnPCBuffStartExpress
	NPCX_SC_END				-	OnPCBuffEndExpress
	NPCX_ENTERMAP			-	OnPCEnterMapExpress
	NPCX_PROGRESSABORT		-	OnPCProgressAbortExpress

觸發行為:
	EVENT_TRIGGER_DISABLED	- 禁止觸發此事件或過濾器
	EVENT_TRIGGER_ONCE		- 允許下次觸發此事件或過濾器
	EVENT_TRIGGER_EVER		- 允許永久觸發此事件或過濾器

--------------------------------------------------------------

*messagecolor "<訊息文字>"{,"<文字顏色程式碼>",<傳送目標>,<遊戲單位編號>};

使用該指令可以傳送指定顏色的訊息文字到聊天視窗中.
除了傳送者以外的其他角色可以見到訊息傳送者角色頭上頂著文字氣泡.

訊息文字:
	訊息的正文, 字串型別, 沒什麼特別的.

文字顏色程式碼:
	可選引數, 預設傳送的字型顏色為白色.
	該引數使用 RRGGBB 格式的字串來傳遞色值, 例如紅色是: "ff0000"

傳送目標:
	bc_all  : 全伺服器的線上玩家都可見.
	bc_map  : 與傳送者處於相同地圖的玩家都可見.
	bc_area : 傳送者視野範圍內的玩家可見 (預設值).
	bc_self : 僅傳送者自己可見.

遊戲單位編號:
	預設情況下的傳送者就是使用該指令指令碼所關聯的玩家,
	必要的情況下您可以使用這個引數來指定其他的傳送者, 以便達到想要的效果.

	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的物件只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>

--------------------------------------------------------------

*copynpc "<複製出來的新NPC所在地圖名稱>,<X座標>,<Y座標>,<朝向編號>","duplicate(<來源NPC名稱>)","<複製出來的新NPC名稱>","<圖檔外觀編號>";
*copynpc "<複製出來的新NPC所在地圖名稱>",<X座標>,<Y座標>,<朝向編號>,"<來源NPC名稱>","<複製出來的新NPC名稱>",<圖檔外觀編號>;

使用該指令可以複製指定的 NPC 到一個新的位置.
該指令從 v1.0.1 版本開始, 擁有兩個不同的引數版本可供隨意選擇, 程式將根據引數的個數進行自動識別.

四引數版本:

	需要攜帶 4 個字串引數, 引數的內容需要指令碼作者進行準確的拼接操作.

	引數看起來很多, 實際上是由 4 個字串引數組成的,
	這 4 個字串與使用 duplicate 進行靜態複製時候的四個用 %TAB% 分隔的內容是一樣的.

	引數說明:
		第一個引數: 字串型別	-	"<複製出來的新NPC所在地圖名稱>,<X座標>,<Y座標>,<朝向編號>"
		第二個引數: 字串型別	-	"duplicate(<來源NPC名稱>)"
		第三個引數: 字串型別	-	"<複製出來的新NPC名稱>"
		第四個引數: 字串型別	-	"<圖檔外觀編號>"

	舉例說明:
		假設有以下 NPC 我們想把它複製一個新的出來:

			prontera,146,99,2	script	PVP管理員::PVPCOPYTEST	123,{
				mes "[PVP管理員]";
				mes "場地正在修理, 請稍後再來...";
				close;
			}

		通常的做法是在指令碼中, 使用 duplicate 指令進行靜態複製, 如:
		
			prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理員#1	123
		
		現在你可以使用 copynpc 指令碼指令, 將上面這一行靜態複製程式碼按 %TAB% 分割為4個欄位,
		然後以字串形式傳遞給 copynpc 指令碼指令, 如:
		
			copynpc "prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理員#2","123";
			
			這裡第二個引數支援簡化 duplicate 關鍵字, 可以用以下語句實現同樣的效果:
			
			copynpc "prontera,156,99,2","PVPCOPYTEST","PVP管理員#2","123";
		
		同時此函式支援返回複製出來的新 NPC 的 GID, 方便你使用 unit 系列指令對其進行操作, 如:
		
			.@gid = copynpc("prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理員#3","123");
			unittalk .@gid, "我是新克隆出來的 NPC 我的 GID 是 : " + .@gid;
		
		如果想要複製一個副本中的 NPC, 那麼需要在用到地圖名稱的地方使用 instance_mapname 進行轉換,
		原始 NPC 的名稱也需要用 instance_npcname 進行轉換, 如:
		
			.@w1$ = instance_mapname("1@tower") + ",156,99,2";
			.@w2$ = "duplicate(" + instance_npcname("PVPCOPYTEST") + ")";
			.@w3$ = "PVP管理員#4";
			.@w4$ = "123";
			
			copynpc .@w1$, .@w2$, .@w3$, .@w4$;

七引數版本:

	需要攜帶 7 個引數, 引數的內容可以直接用對應型別的變數直接傳遞, 更方便理解.
	
	引數說明:
		第一個引數: 字串型別	-	"<複製出來的新NPC所在地圖名稱>"
		第二個引數: 數值型別	-	<X座標>
		第三個引數: 數值型別	-	<Y座標>
		第四個引數: 數值型別	-	<朝向編號>
		第五個引數: 字串型別	-	"<來源NPC名稱>"
		第六個引數: 字串型別	-	"<複製出來的新NPC名稱>"
		第七個引數: 數值型別	-	<圖檔外觀編號>

	舉例說明:
		假設有以下 NPC 我們想把它複製一個新的出來:

			prontera,146,99,2    script    PVP管理員::PVPCOPYTEST    123,{
				mes "[PVP管理員]";
				mes "場地正在修理, 請稍後再來...";
				close;
			}

		通常的做法是在指令碼中, 使用 duplicate 指令進行靜態複製, 如:
		
			prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理員#1	123
		
		現在你可以使用 copynpc 指令碼指令直接複製:
		
			copynpc "prontera",156,99,2,"duplicate(PVPCOPYTEST)","PVP管理員#2",123;
			
			這裡第二個引數支援簡化 duplicate 關鍵字, 可以用以下語句實現同樣的效果:
			
			copynpc "prontera",156,99,2,"PVPCOPYTEST","PVP管理員#2",123;
		
		同時此函式支援返回複製出來的新 NPC 的 GID, 方便你使用 unit 系列指令對其進行操作, 如:
		
			.@gid = copynpc("prontera",156,99,2,"PVPCOPYTEST","PVP管理員#3",123);
			unittalk .@gid, "我是新克隆出來的 NPC 我的 GID 是 : " + .@gid;
		
		如果想要複製一個副本中的 NPC, 那麼需要在用到地圖名稱的地方使用 instance_mapname 進行轉換,
		原始 NPC 的名稱也需要用 instance_npcname 進行轉換, 如:
		
			copynpc instance_mapname("1@tower"),156,99,2,instance_npcname("PVPCOPYTEST"),"PVP管理員#4",123;

公用說明:

	返回值:
		複製成功則返回複製出來的新 NPC 的 GID, 失敗則返回 0

	注意事項:
		複製商店型別的 NPC 時, 來源 NPC 和目標 NPC 它們之間的道具列表是相互獨立的.
		
		若指定了一個無效的外觀編號, 那麼地圖伺服器雖然會報 status_set_viewdata 錯誤,
		但是實際上 NPC 還是會複製成功 (只不過你看不見它).
		此時可以用 setunitdata 調整這個 NPC 的 UNPC_DISPLAY 引數, 重新給他一個外觀.

--------------------------------------------------------------

*gettimefmt <"時間格式化標準">{,<要轉換的秒數>{,<是否格式化成 UTC 時間>}};

時間格式化標準:
	與 gettimestr 函式的第一個引數完全一樣.
	可以參考: https://www.runoob.com/cprogramming/c-function-strftime.html

要轉換的秒數:
	可選引數, 如果你指定了一個秒數, 那麼指令將不會轉換當前系統時間, 而是轉換你給定的時間

是否格式化成 UTC 時間:
	可選引數, 預設值為 0, 填寫 1 表示是. 如果格式化成 UTC 時間, 則不會包含時區.
	
	dispbottom gettimefmt("%H:%M:%S", 10);		// 在北京的話, 返回: 08:00:10 (北京時區是 UTC + 08:00:00)
	dispbottom gettimefmt("%H:%M:%S", 10, 1);	// 返回: 00:00:10

返回值:
	成功則返回被格式化的時間, 失敗則返回空字串

--------------------------------------------------------------

*mpet <魔物編號>{,<魔物編號>...}
*multicatchpet <魔物編號>{,<魔物編號>...}

與 pet / catchpet 指令類似, 但可以設定多個支援捕捉的魔物編號

魔物編號:
	必須是存在於 db/{pre-}re/pet_db.yml 中定義的魔物編號
	沒有定義在 pet_db.yml 的魔物, 我們無法知道它的食物和飢餓率等資料

返回值:
	該指令無論成功失敗, 都不會有返回值

--------------------------------------------------------------

*selfdeletion {<自毀策略>}

該指令與 unloadnpc 類似, 但可以控制自毀當前 NPC,
包括一些更細膩的自毀時機控制. 哪怕 NPC 沒有關聯到玩家, 也可以完成自毀.

自毀策略:
	SELFDEL_NOW       - 控制當前 NPC 終止全部正在與其互動的玩家對話, 並立刻自毀 (預設值)
	SELFDEL_WAITFREE  - 當最後一個正在與其互動的玩家對話結束後, 再進行自毀 (無論是否有工作中的定時器)
	SELFDEL_CANCEL    - 取消 SELFDEL_WAITFREE 設定的自毀標記

返回值:
	該指令無論成功失敗, 都不會有返回值

場景建議:
	常用於配合 copynpc 指令, 實現進行挖礦\釣魚\開寶箱等與 NPC 對話完畢後 NPC 會消失的場景.

注意事項:
	在 NPC 中 callfunc 某個 function, 在這個 function 中呼叫的 selfdeletion 將對呼叫者 NPC 生效.

--------------------------------------------------------------

*setchartitle <稱號ID>{,<角色編號>};

設定指定玩家角色的稱號ID
該指令只在客戶端封包版本大於等於 20150513 的時候有效.

稱號ID:
	稱號ID在客戶端的 data\luafiles514\lua files\datainfo\titletable.lub 中獲取.
	服務端並不清楚客戶端會將某個稱號ID呈現出什麼樣的字串.

返回值:
	設定成功則返回 1, 設定失敗則返回 0

--------------------------------------------------------------

*getchartitle {<角色編號>};

獲得指定玩家角色的稱號ID
該指令只在客戶端封包版本大於等於 20150513 的時候有效.

返回值:
	設定成功則返回目標玩家的稱號ID (若為 0 則表示此玩家沒有稱號)
	獲取失敗則返回 -1

--------------------------------------------------------------

*npcexists "<NPC名稱>"{,<用於儲存 GameID 的變數>};

判斷指定名稱的 NPC 是否存在, 就算 NPC 不存在控制檯也不會報錯
不過用法錯誤的話還是一樣會報錯的, 比如: 第二個引數傳遞了一個字串變數

NPC名稱:
	想要確認的 NPC 名稱, 需要使用 NPC 的唯一名稱 (::name)
	技巧: 寫指令碼之前可以使用 strnpcinfo 型別 3 來查詢當前 NPC 的唯一名稱.
	就是名字最長, 且全服唯一的那個 NPC 名稱就是了.

用於儲存 GameID 的變數:
	有時候當你確認某個 NPC 存在後, 可能希望對此單位進行其他操作
	那麼可以傳遞一個"數值型"的變數, 如果目標單位存在, 那麼程式將自動填充 GameID 返回
	如果目標單位不存在, 那麼指定的變數內容將會被設定為 0

返回值:
	存在返回 1, 不存在返回 0

--------------------------------------------------------------

*storagegetitem <物品編號>,<數量>{,<賬號編號>};
*storagegetitem "<物品名稱>",<數量>{,<賬號編號>};

該指令能夠直接往個人倉庫建立指定的道具.
在全部倉庫都處於關閉狀態的時候才能使用該指令來建立道具.
若倉庫已滿且建立的道具可被丟在地上, 那麼道具將會被丟在角色附近的地面上.

物品編號/名稱:
	想要建立到倉庫的物品編號, 或者物品名稱.

數量:
	想要建立的道具數量, 若是不可堆疊的道具, 則會被建立多個.

賬號編號:
	可選引數, 若指定了對應的賬號編號, 則操作的是指定賬號的倉庫.
	若不提供此引數則關聯當前呼叫該指令的玩家.

資訊透過變數返回:
	@stored_count		成功新增到倉庫的道具數量
	@unstored_count		沒能新增到倉庫的道具數量
	@onfloor_count		沒能新增到倉庫的道具中有幾個掉落到地面

返回值:
	新增成功則返回 0, 若失敗則返回小於 0 的錯誤程式碼:

	-1	-	指定的物品不存在
	-2	-	指定的物品數量不合法 (比如給了個負數)
	-3	-	當前指令不使用此錯誤程式碼
	-4	-	沒有關聯到玩家, 因此無法找到對應的個人倉庫
	-5	-	某個倉庫處於開啟狀態, 需要先關閉倉庫才能繼續使用
	-6	-	指定的道具不能存放到倉庫
	-7	-	本指令暫時不支援建立寵物蛋道具
	-8	-	您沒有許可權往個人倉庫儲存道具 (基本不可能發生)
	-9	-	道具放入倉庫時失敗了, 並且該道具無法掉落到地面上
	-10	-	道具放入倉庫時失敗了, 掉落到了地面上

注意事項:
	密集呼叫該指令時(比如寫個迴圈呼叫幾百次), 呼叫者玩家可能會卡一下.
	
	為了降低效能影響, 執行該指令後不會立刻強制伺服器儲存倉庫內容.
	需要等待下一次自動儲存資料時, 才會將最新的倉庫資料發給角色伺服器儲存.
	
	返回值 -9 和 -10 只有當 <數量> 等於 1 的時候才會返回,
	若你呼叫時候 <數量> 大於 1, 那麼即使存在掉落地面的道具也會返回 0,
	此時可以透過返回變數來確認詳細的地面掉落情況.

--------------------------------------------------------------

*storagegetitembound <物品編號>,<數量>,<道具繫結型別>{,<賬號編號>};
*storagegetitembound "<物品名稱>",<數量>,<道具繫結型別>{,<賬號編號>};

該指令與 storagegetitem 類似, 只不過是能夠指定建立道具的繫結型別.

道具繫結型別:
	Bound_None      -   沒有繫結 (與 0 等價, 但更推薦用常量)
	Bound_Account   -   繫結賬號的道具, 可放個人倉庫, 全賬號共享
	Bound_Guild     -   繫結公會的道具, 可放公會倉庫與他人共享, 擁有物品的人離開公會後物品消失
	Bound_Party     -   繫結隊伍的道具, 離開隊伍後消失
	Bound_Char      -   繫結角色的道具, 不能放個人倉庫

返回值:
	新增成功則返回 0, 若失敗則返回小於 0 的錯誤程式碼:

	-1	-	指定的物品不存在
	-2	-	指定的物品數量不合法 (比如給了個負數)
	-3	-	指定的道具繫結型別無效
	-4	-	沒有關聯到玩家, 因此無法找到對應的個人倉庫
	-5	-	某個倉庫處於開啟狀態, 需要先關閉倉庫才能繼續使用
	-6	-	指定的道具不能存放到倉庫
	-7	-	本指令暫時不支援建立寵物蛋道具
	-8	-	您沒有許可權往個人倉庫儲存道具 (基本不可能發生)
	-9	-	道具放入倉庫時失敗了, 並且該道具無法掉落到地面上
	-10	-	道具放入倉庫時失敗了, 掉落到了地面上

--------------------------------------------------------------

*premiumstoragegetitem <倉庫編號>,<物品編號>,<數量>{,<賬號編號>};
*premiumstoragegetitem <倉庫編號>,"<物品名稱>",<數量>{,<賬號編號>};

該指令能夠直接往拓展倉庫建立指定的道具.
在全部倉庫都處於關閉狀態的時候才能使用該指令來建立道具.
若倉庫已滿且建立的道具可被丟在地上, 那麼道具將會被丟在角色附近的地面上.

倉庫編號:
	該指令支援獲取擴充倉庫的內容, 因此你需要在查詢時指定倉庫編號.

	0 - 個人倉庫 (每個玩家都會有的預設倉庫)
	X - 擴充倉庫 (其他非 0 的定義在 conf/inter_athena.yml 中的有效倉庫編號)

物品編號/名稱:
	想要建立到倉庫的物品編號, 或者物品名稱.

數量:
	想要建立的道具數量, 若是不可堆疊的道具, 則會被建立多個.

賬號編號:
	可選引數, 若指定了對應的賬號編號, 則操作的是指定賬號的倉庫.
	若不提供此引數則關聯當前呼叫該指令的玩家.

資訊透過變數返回:
	@stored_count		成功新增到倉庫的道具數量
	@unstored_count		沒能新增到倉庫的道具數量
	@onfloor_count		沒能新增到倉庫的道具中有幾個掉落到地面

返回值:
	新增成功則返回 0, 若失敗則返回小於 0 的錯誤程式碼:

	-1	-	指定的物品不存在
	-2	-	指定的物品數量不合法 (比如給了個負數)
	-3	-	當前指令不使用此錯誤程式碼
	-4	-	沒有關聯到玩家, 因此無法找到對應的拓展倉庫
	-5	-	某個倉庫處於開啟狀態, 需要先關閉倉庫才能繼續使用
	-6	-	指定的道具不能存放到倉庫
	-7	-	本指令暫時不支援建立寵物蛋道具
	-8	-	您沒有許可權往拓展倉庫儲存道具 (基本不可能發生)
	-9	-	道具放入倉庫時失敗了, 並且該道具無法掉落到地面上
	-10	-	道具放入倉庫時失敗了, 掉落到了地面上

注意事項:
	密集呼叫該指令時(比如寫個迴圈呼叫幾百次), 呼叫者玩家可能會卡一下.
	
	為了降低效能影響, 執行該指令後不會立刻強制伺服器儲存倉庫內容.
	需要等待下一次自動儲存資料時, 才會將最新的倉庫資料發給角色伺服器儲存.
	
	返回值 -9 和 -10 只有當 <數量> 等於 1 的時候才會返回,
	若你呼叫時候 <數量> 大於 1, 那麼即使存在掉落地面的道具也會返回 0,
	此時可以透過返回變數來確認詳細的地面掉落情況.

--------------------------------------------------------------

*premiumstoragegetitembound <倉庫編號>,<物品編號>,<數量>,<道具繫結型別>{,<賬號編號>};
*premiumstoragegetitembound <倉庫編號>,"<物品名稱>",<數量>,<道具繫結型別>{,<賬號編號>};

該指令與 premiumstoragegetitem 類似, 只不過是能夠指定建立道具的繫結型別.

道具繫結型別:
	Bound_None      -   沒有繫結 (與 0 等價, 但更推薦用常量)
	Bound_Account   -   繫結賬號的道具, 可放個人倉庫, 全賬號共享
	Bound_Guild     -   繫結公會的道具, 可放公會倉庫與他人共享, 擁有物品的人離開公會後物品消失
	Bound_Party     -   繫結隊伍的道具, 離開隊伍後消失
	Bound_Char      -   繫結角色的道具, 不能放個人倉庫

返回值:
	新增成功則返回 0, 若失敗則返回小於 0 的錯誤程式碼:

	-1	-	指定的物品不存在
	-2	-	指定的物品數量不合法 (比如給了個負數)
	-3	-	指定的道具繫結型別無效
	-4	-	沒有關聯到玩家, 因此無法找到對應的拓展倉庫
	-5	-	某個倉庫處於開啟狀態, 需要先關閉倉庫才能繼續使用
	-6	-	指定的道具不能存放到倉庫
	-7	-	本指令暫時不支援建立寵物蛋道具
	-8	-	您沒有許可權往拓展倉庫儲存道具 (基本不可能發生)
	-9	-	道具放入倉庫時失敗了, 並且該道具無法掉落到地面上
	-10	-	道具放入倉庫時失敗了, 掉落到了地面上

--------------------------------------------------------------

*getcharmac <賬戶編號>/<角色編號>/<"角色名稱">;

與 getcharip 類似, 該指令用於獲取玩家登入時客戶端網絡卡的 MAC 地址
但必須要求客戶端使用 SSO 方式進行登入才會有記錄

注意事項:
	如果無法讀取到 MAC 地址, 那麼請先確保客戶端使用 SSO 方式登入
	如果成功讀取到 MAC 地址, 格式應為: "00-00-00-00-00-00"

使用建議:
	哪怕讀取到的返回值不是空字串, 也應判斷是否等於 "00-00-00-00-00-00"
	如果等於 "00-00-00-00-00-00" 也可以認為是沒讀取到

返回值:
	成功則返回 MAC 地址, 讀取不到則返回空字串

--------------------------------------------------------------

*getconstant <"常量字串">;

查詢一個常量字串對應的數值. 當你僅知道一個常量字串, 
且試圖將它轉換成數值引數傳遞給其他函式時使用

返回值:
	成功則返回常量對應的數值, 查詢失敗則返回 -255

--------------------------------------------------------------

*preg_search <"字串">,<"匹配表示式">,<拓展標記位>,<存放匹配結果的字串陣列>;

執行一個正規表示式搜尋並返回首個匹配的分組內容

字串:
	待匹配的字串, 正規表示式將從中搜尋你需要的資訊

匹配表示式:
	正則匹配表示式 (pattern), 程式將根據該表示式提取分組內容

拓展標記位:
	掩碼選項, 目前可選的只有一個值:
	
	1	-	匹配時忽略大小寫

存放匹配結果的字串陣列:
	填寫用於返回分組結果的字串陣列名稱(無需中括號)

返回值:
	返回負數表示錯誤, 其他正整數表示匹配到的分組個數 (其中 0 通常不應該出現, 出現也可以當錯誤)

注意事項:
	讀取陣列內容時, 請不要使用 getarraysize 去探測陣列的長度.
	因為實際匹配過程中, 如果剛好匹配結果的末尾分組內容為空字串,
	那麼 getarraysize 讀取陣列長度的時候, 它會將空字串元素忽略, 導致無法獲取正確的陣列長度.
	
	如果需要遍歷, 則應該使用函式的返回值來作為陣列內容的長度.

示例程式碼:
	prontera,150,150,5	script	正則搜尋測試	123,{
		// 目標: 提取其中的 HAT_EF_FLUTTER_BUTTERFLY 常量 (左右故意加空格)
		.@text$ = "  hateffect HAT_EF_FLUTTER_BUTTERFLY,true; ";
		
		// 下面是提取用的正規表示式
		// 正規表示式學習成本較高, 一旦掌握, 處理字串將會達到一個全新的高度
		.@patt$ = ".*?(hateffect(\s{1,}|\()(\(|)\s*(.*?)\s*,\s*(.*?)\s*(|\))(\s*|);)";
		
		// 準備個字串陣列用來存返回的內容 (可以不用特意 setarray, 只是為了示例)
		setarray .@groups$[0],"";
		
		// 注意: 字串陣列名應該以 $ 結尾, 實際傳遞給 preg_search 時無需攜帶中括號
		.@match = preg_search(.@text$, .@patt$, 1, .@groups$);
		
		if (.@match <= 0) {
			dispbottom "很抱歉, 匹配失敗了...";
			end;
		}
		
		// 迴圈遍歷輸出一下匹配到的內容, 若無意外第 5 個元素 (索引 4) 就是我們要的內容
		for (.@i = 0; .@i < .@match; .@i++) {
			dispbottom ".@groups$[" + .@i + "] = " + .@groups$[.@i];
		}
		
		end;
	}

--------------------------------------------------------------

*aura <光環編號>{,<角色編號>};

使角色可以啟用指定的光環特效.
光環本質是一組 Effect 效果的組合, 光環編號定義在 db/aura_db.yml 檔案中.

光環編號:
	若光環編號為 0 則表示取消光環

返回值:
	成功返回 1, 失敗返回 0

使用建議:
	若想知道當前角色使用的光環編號, 直接訪問 PANDAS_AURASET 角色變數即可

注意事項:
	在客戶端封包版本小於 20181002 的情況下, 獲取/失去光環的玩家單位客戶端
	會黑屏一下以便重新整理光環效果. 為獲取最佳的光環效果, 建議使用客戶端封包
	版本大於等於 20181002 的客戶端.

--------------------------------------------------------------

*unitaura <遊戲單位編號>,<光環編號>;

使指定的單位可以啟用指定的光環特效.
光環本質是一組 Effect 效果的組合, 光環編號定義在 db/aura_db.yml 檔案中.

若你已經知道某個玩家/魔物/傭兵/寵物/NPC/精靈/人工生命體的 <遊戲單位編號>,
那麼也可以為他們套上一個光環 (但只有玩家的光環會記錄在資料庫中, 並且會在
重啟地圖伺服器後還能被恢復光環, 其他的幾種單位他們的光環會持續生效到地圖
伺服器退出為止)

遊戲單位編號:
	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的物件只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>	

光環編號:
	若光環編號為 0 則表示取消光環

返回值:
	成功返回 1, 失敗返回 0

注意事項:
	在客戶端封包版本小於 20181002 的情況下, 獲取/失去光環的玩家單位客戶端
	會黑屏一下以便重新整理光環效果. 為獲取最佳的光環效果, 建議使用客戶端封包
	版本大於等於 20181002 的客戶端.

--------------------------------------------------------------

*getunitdata <遊戲單位編號>,<用於儲存返回資料的陣列名稱>;
*setunitdata <遊戲單位編號>,<引數>,<新的值>;

在原先 rAthena 官方返回的資訊基礎上, <引數>和<返回的陣列>中新增了以下索引:

	UMOB_AURA - 讀取或設定魔物的光環編號
	UHOM_AURA - 讀取或設定生命體的光環編號
	UPET_AURA - 讀取或設定寵物的光環編號
	UMER_AURA - 讀取或設定傭兵的光環編號
	UELE_AURA - 讀取或設定精靈的光環編號
	UNPC_AURA - 讀取或設定NPC 的光環編號
	
	UMOB_DAMAGETAKEN - 讀取或設定指定魔物的承傷倍率
		若值為 -1 則表示直接使用魔物在 db 中設定的預設承傷倍率
		設為 100 則表示魔物受到的傷害是 100%
		設為 80 則表示玩家給魔物造成的傷害只會發揮 80% 的傷害量
		設為 120 則表示玩家給魔物造成的傷害將發揮 120% 的傷害量
		取值範圍: 從 -1 到 65535
	UMOB_DAMAGETAKEN_DB - 讀取指定魔物在 db 中設定的預設承傷倍率
		注意: 該引數不能用於 setunitdata 指令
	
	UMOB_MOBBASEEXP - 讀取或設定魔物的基礎經驗值
		若值為 -1 則表示直接使用魔物在 db 中設定的預設基礎經驗值
		取值範圍: 從 -1 到 (2^63 - 1)
		注意: 此經驗值在最終給玩家的時候會經歷各種加成計算, 比如: 經驗倍增書、VIP 會員加成等
	UMOB_MOBBASEEXP_DB - 讀取指定魔物在 db 中設定的預設基礎經驗值
		注意: 該引數不能用於 setunitdata 指令

	UMOB_MOBJOBEXP - 讀取或設定魔物的職業經驗值
		若值為 -1 則表示直接使用魔物在 db 中設定的預設職業經驗值
		取值範圍: 從 -1 到 (2^63 - 1)
		注意: 此經驗值在最終給玩家的時候會經歷各種加成計算, 比如: 經驗倍增書、VIP 會員加成等
	UMOB_MOBJOBEXP_DB - 讀取指定魔物在 db 中設定的預設職業經驗值
		注意: 該引數不能用於 setunitdata 指令

	UPET_VIEW_CLASS - 讀取或設定指定寵物的 Class 外觀編號

--------------------------------------------------------------

*getunittarget <遊戲單位編號>;

獲取指定單位當前正在攻擊的目標單位編號.
支援的單位型別: 玩家/魔物/傭兵/寵物/NPC/精靈/人工生命體

遊戲單位編號:
	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的物件只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>	

返回值:
	返回 0 表示沒有攻擊目標, 非零則代表: 目標的遊戲單位編號

注意事項:
	若給定的遊戲單位編號不存在, 返回值也是 0

--------------------------------------------------------------

*unlockcmd;

解鎖實時事件和過濾器事件的指令限制, 只能用於實時或過濾器事件

返回值:
	該指令沒有任何返回值

提示資訊:
	用法和 disable_items; 類似, 直接呼叫即可 

--------------------------------------------------------------

*batrec_query <記錄宿主的單位編號>,<互動目標的單位編號>,<記錄型別>{,<聚合規則>};

該指令可以查詢指定單位的戰鬥記錄, 確認與互動目標單位產生的具體記錄值.

記錄宿主的單位編號:
	比如想查詢某個魔物的戰鬥記錄, 那就傳遞此魔物的遊戲單位編號

互動目標的單位編號:
	比如想查詢玩家對魔物的記錄值(或者叫: 傷害值), 則此處傳遞玩家的遊戲單位編號(賬號編號)

記錄型別:
	BRT_DMG_RECEIVE		- 承傷記錄 (記錄宿主受到互動目標的傷害記錄)
	BRT_DMG_CAUSE		- 輸出記錄 (記錄宿主攻擊互動目標的傷害記錄)

聚合規則:
	BRA_COMBINE			- 按主人為單位合併查詢, 預設值 (寵物/傭兵等擁有主人的生命體, 傷害值計算到主人頭上)
	BRA_DISCRETE		- 按獨立單位進行查詢 (可以單獨查詢寵物/傭兵對記錄宿主的(被)攻擊記錄)

返回值:
	返回 -1 表示查無記錄或發生錯誤, 含 0 正整數表示傷害值

提示資訊:
	若返回的傷害值是 0, 則表示互動單位和宿主之間發生了沒有傷害的技能互動 (比如: 緩速術)
	
	每個單位都有自己的戰鬥記錄資訊, 單位被銷燬之前記錄都在.
	記錄數上限沒有限制, 但越多的記錄會開銷越多記憶體.
	
	您可以在 OnUnitKillExpress 單位死亡事件中獲取戰鬥記錄的內容以便立即使用它們,
	或者將戰鬥記錄陣列儲存到其他地方.

--------------------------------------------------------------

*batrec_rank <記錄宿主的單位編號>,<返回互動目標的單位編號陣列>,<返回記錄值陣列>,<記錄型別>{,<聚合規則>{,<排序規則>}};

查詢指定單位的戰鬥記錄並對記錄的值進行排序, 返回排行榜單

記錄宿主的單位編號:
	比如想查詢某個魔物的戰鬥記錄, 那就傳遞此魔物的遊戲單位編號

返回互動目標的單位編號陣列:
	指定一個數值型陣列, 用於接收按序排列後的遊戲單位編號.
	提示: 無論呼叫成功與否該陣列的內容都將被清空
	
	注意: 玩家單位返回的是角色編號而不是遊戲單位編號.
	若需獲取玩家的遊戲單位編號, 建議用: convertpcinfo 指令進行轉換.

返回記錄值陣列:
	指定一個數值型陣列, 用於接收與單位編號陣列一一對應的記錄值.
	提示: 無論呼叫成功與否該陣列的內容都將被清空

記錄型別:
	BRT_DMG_RECEIVE		- 承傷記錄 (記錄宿主受到互動目標的傷害記錄)
	BRT_DMG_CAUSE		- 輸出記錄 (記錄宿主攻擊互動目標的傷害記錄)

聚合規則:
	BRA_COMBINE			- 按主人為單位合併查詢, 預設值 (寵物/傭兵等擁有主人的生命體, 傷害值計算到主人頭上)
	BRA_DISCRETE		- 按獨立單位進行查詢 (可以單獨查詢寵物/傭兵對記錄宿主的(被)攻擊記錄)

排序規則:
	BRS_DESC			- 排行榜按記錄值降序排列, 預設值 (記錄值越大排名越靠前)
	BRS_ASC				- 排行榜按記錄值升序排列 (記錄值越小排名越靠前)

返回值:
	失敗返回 -1, 含 0 正整數表示陣列中返回的榜單記錄數

提示資訊:
	若返回的傷害值是 0, 則表示互動單位和宿主之間發生了沒有傷害的技能互動 (比如: 緩速術)
	
	每個單位都有自己的戰鬥記錄資訊, 單位被銷燬之前記錄都在.
	記錄數上限沒有限制, 但越多的記錄會開銷越多記憶體.
	
	您可以在 OnUnitKillExpress 單位死亡事件中獲取戰鬥記錄的內容以便立即使用它們,
	或者將戰鬥記錄陣列儲存到其他地方.
 
--------------------------------------------------------------

*batrec_sortout <記錄宿主的單位編號>{,<記錄型別>};

該指令移除指定宿主的戰鬥記錄中, 互動單位已經不存在 (或下線) 的記錄

記錄宿主的單位編號:
	比如想處理某個魔物的戰鬥記錄, 那就傳遞此魔物的遊戲單位編號

記錄型別:
	可選, 不傳遞此引數則表示處理全部記錄
	BRT_DMG_RECEIVE		- 承傷記錄 (記錄宿主受到互動目標的傷害記錄)
	BRT_DMG_CAUSE		- 輸出記錄 (記錄宿主攻擊互動目標的傷害記錄)

返回值:
	該指令無論成功與否, 都不會有返回值

--------------------------------------------------------------

*batrec_reset <記錄宿主的單位編號>;

清除指定單位的戰鬥記錄資訊

記錄宿主的單位編號:
	比如想清除某個魔物的戰鬥記錄, 那就傳遞此魔物的遊戲單位編號

返回值:
	該指令無論成功與否, 都不會有返回值

--------------------------------------------------------------

*enable_batrec {<遊戲單位編號>};
*disable_batrec {<遊戲單位編號>};

啟用或禁用指定單位的戰鬥記錄.

遊戲單位編號:
	可選值, 若不傳遞則表示控制當前關聯到指令碼的角色

提示資訊:
	您可以透過 batrec_autoenabled_unit 戰鬥配置選項來控制哪些單位會自動啟用戰鬥記錄.

	玩家預設是不會啟動戰鬥記錄的, 因此需要使用該指令手動開啟.
	玩家角色在開啟記錄後, 除非玩家下線或者被明確的禁用, 否則將會一直記錄.
	
	由於記錄本身沒上限, 因此玩家線上一直玩, 累計攻擊成千上萬個魔物的話,
	在呼叫 batrec_sortout 進行整理之前, 對這些魔物的輸出和承傷記錄將被長時間儲存在記憶體中.
	
	對於玩家角色來說, 開啟戰鬥記錄後若太久忘記關閉會導致地圖伺服器記憶體佔用持續提高.

返回值:
	該指令無論成功與否, 都不會有返回值

--------------------------------------------------------------

*login <角色編號>{,<預設是否坐下>{,<預設身體朝向>{,<預設腦袋朝向>{,<登入模式>}}}};

將指定的角色以特定的登入模式拉上線

角色編號:
	指定一個想使之上線的角色編號

預設是否坐下:
	0 表示站立, 1 表示坐下
	可選值, 預設值為: 0

	此選項會被 suspend_{afk|normal|offline}_sitdown 戰鬥配置選項覆蓋
	具體被哪個選項影響取決於 <登入模式> 的值

預設身體朝向:
    1 = 西北      0 = 正北      7 = 東北
              ↖     |     ↗
    2 = 正西  <-     +     ->   6 = 正東
              ↙     |     ↘
    3 = 西南      4 = 正南      5 = 東南
	可選值, 預設值為: 4 (正南)
	
	此選項會被 suspend_{afk|normal|offline}_bodydirection 戰鬥配置選項覆蓋
	具體被哪個選項影響取決於 <登入模式> 的值

預設腦袋朝向:
	0 = 相對於身體朝向的正前方, 頭部看向正前方
	1 = 相對於身體朝向的正前方, 頭部看向右看
	2 = 相對於身體朝向的正前方, 頭部看向左看
	可選值, 預設值為: 0 (正前方)
	
	此選項會被 suspend_{afk|normal|offline}_headdirection 戰鬥配置選項覆蓋
	具體被哪個選項影響取決於 <登入模式> 的值

登入模式:
	SUSPEND_MODE_OFFLINE	- 掛機模式
	SUSPEND_MODE_AFK		- 離開模式 (AFK)
	SUSPEND_MODE_NORMAL		- 普通模式
	可選值, 預設值為: SUSPEND_MODE_NORMAL

提示資訊:
	請不要在 OnInit / OnInterIfInit / OnInterIfInitOnce 事件中使用該指令,
	因為在觸發這幾個事件的時候伺服器並未就緒.
	
	若必須要在這個時機使用本指令的話, 可以使用 addtimer 將延遲幾秒再執行.

返回值:
	成功返回 1, 失敗返回 0

--------------------------------------------------------------

*checksuspend {<角色編號|賬號編號|"角色名稱">};

獲取指定角色或指定賬號當前線上角色的掛機模式

角色編號|賬號編號|"角色名稱":
	可選值, 不傳遞則表示檢查當前指令碼所關聯的角色

返回值:
	-1 						- 表示指定的角色不存在
	SUSPEND_MODE_NONE		- 角色並沒有處於任何掛機模式
	SUSPEND_MODE_OFFLINE	- 處於 @suspend 指令帶來的離線掛機模式
	SUSPEND_MODE_AFK		- 處於 @afk 指令帶來的離開模式
	SUSPEND_MODE_NORMAL		- 處於 login 指令碼指令帶來的普通掛機模式

提示資訊:
	若想檢查是否處於離線掛店模式, 可以使用 checkvending 指令碼指令

--------------------------------------------------------------

*unitexists <遊戲單位編號>{,<單位是否必須存活>};

用來判斷指定的遊戲單位是否存在.
在 rAthena 的基礎上拓展了 <單位是否必須存活> 引數.

遊戲單位編號:
	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的物件只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>	

單位是否必須存活:
	可選值, 填寫 1 表示要求單位必須存活才認為單位存在;
	不填或者填寫 0 則認為單位存在就好無需判斷是否存活

返回值:
	指定的單位存在則返回 true 否則返回 false

--------------------------------------------------------------

*bonus_script <"效果指令碼程式碼">,<生效時長>{,<標記>{,<型別>{,<狀態圖示>{,<角色編號>}}}};

在 rAthena 的功能基礎上, 熊貓模擬器拓展了它的返回值.
各引數的詳細說明請直接參考 doc/script_commands.txt 中 bonus_script 的說明.

返回值:
	執行成功則返回該 bonus_script 例項的唯一編號,
	執行失敗, 或者 bonus_script 在沒有指定 2048 強制覆蓋標記的情況下已存在則返回 0.
	此處的唯一編號可以用於 bonus_script_remove 等拓展指令.

注意事項:
	正常情況下連續執行兩次相同的 bonus_script 只有第一次能獲得編號, 如:

		// 第一次, .@bonusid 將返回有效的唯一編號
		.@bonusid = bonus_script("{ bonus bStr,5; }",60);
		
		// 第二次, 沒有特殊指定強制覆蓋標記, 雖然時間會重置, 但返回值將依然是 0
		.@bonusid = bonus_script("{ bonus bStr,5; }",60);

	bonus_script 的 <標記> 允許您設定 2048 來強制重複 bonus_script 指令碼, 如:
	
		// 第一次, .@bonusid 將返回有效的唯一編號, 比如: 644245094400002
		.@bonusid = bonus_script("{ bonus bStr,5; }",60,2048);
	
		// 第二次, .@bonusid 也會返回有效的唯一編號, 但將於第一次建立時的編號不同, 比如: 644245094400003
		.@bonusid = bonus_script("{ bonus bStr,5; }",60,2048);
		
		在這種情況下, 兩次建立的 bonus_script 將同時生效, 在它們同時生效期間角色的 STR 將會是 +10

--------------------------------------------------------------

*bonus_script_remove <效果指令碼編號>{,<角色編號>};

用於移除指定的 bonus_script 效果指令碼.

效果指令碼編號:
	當時呼叫 bonus_script 指令成功後, 會返回一個效果指令碼編號.
	傳入這個編號即可將這個效果指令碼移除

返回值:
	成功移除則返回 true, 找不到指令碼程式碼或移除失敗則返回 false

--------------------------------------------------------------

*bonus_script_list <返回效果指令碼編號的數值型陣列>{,<角色編號>};

用於獲取指定角色當前啟用的全部 bonus_script 效果指令碼編號.
效果指令碼編號在呼叫 bonus_script 成功後會返回.

返回效果指令碼編號的數值型陣列:
	數值型別的陣列, 用於接收指定角色當前已被啟用的效果指令碼編號.
	提示: 無論呼叫成功與否該陣列的內容都將被清空

返回值:
	獲取到的效果指令碼編號數量, 發生錯誤則返回 -1

--------------------------------------------------------------

*bonus_script_exists <效果指令碼編號>{,<角色編號>};

用於查詢指定角色是否已經啟用了特定的 bonus_script 效果指令碼.

效果指令碼編號:
	當時呼叫 bonus_script 指令成功後, 會返回一個效果指令碼編號.
	傳入這個編號即可查詢該指令碼效果是否還存在.

返回值:
	效果存在則返回 true, 角色不線上或效果不存在否則返回 false

--------------------------------------------------------------

*bonus_script_getid <"效果指令碼程式碼">,<返回效果指令碼編號陣列>{,<角色編號>};

用於查詢指定效果指令碼程式碼字串在指定角色上所對應的效果指令碼編號,
若有多個重疊則返回多個效果指令碼編號.

效果指令碼程式碼:
	想要查詢的效果指令碼程式碼字串,
	必須和呼叫 bonus_script 指令碼時傳入的第一個引數一模一樣

返回效果指令碼編號陣列:
	數值型別的陣列, 由於同一個角色身上可以透過 bonus_script 的 2048 標記來建立
	多個重疊的效果指令碼, 因此這裡可能會返回多個效果指令碼編號

返回值:
	查詢到的記錄數, 若為 -1 表示出錯; 若為 0 則表示無記錄;
	其他非 0 正整數表示陣列中返回的效果指令碼編號數量

--------------------------------------------------------------

*bonus_script_info <效果指令碼編號>,<查詢型別>{,<角色編號>};

用於查詢指定效果指令碼的相關資訊.
只需要提供指定的效果指令碼編號, 並且該效果在指定角色身上處於啟用狀態,
就可以查詢到它的相關資訊.

效果指令碼編號:
	當時呼叫 bonus_script 指令成功後, 會返回一個效果指令碼編號.
	傳入這個編號即可查詢該指令碼效果是否還存在.

查詢型別:
	0	-	效果指令碼程式碼, 返回字串型別的值
	1	-	標記位. 即呼叫 bonus_script 時傳遞的 flag 欄位值
	2	-	狀態圖示編號. 即呼叫 bonus_script 時傳遞的 status_icon 欄位值
	3	-	效果型別. 即呼叫 bonus_script 時傳遞的 type 欄位值
	4	-	剩餘時間 (單位為毫秒)

返回值:
	若指定的角色不存在則返回 -2
	給定的效果指令碼編號不存在則返回 -3
	若給定的查詢型別不在有效的範圍內則返回 -4
	
	其中除查詢型別 1 的返回值為字串外, 其他查詢型別的返回值皆為數值型.
	其中查詢型別 2 返回 -1 表示沒有圖示.
	其中查詢型別 4 返回 -1 表示該效果指令碼永不超時.

--------------------------------------------------------------

*expandinventory_adjust <增加多少容量>;

用於調整角色的揹包容量上限.

增加多少容量:
	玩家現在容量是 100 你想把它調整為 115, 那麼此處只需要傳遞 15 即可

返回值:
	調整成功返回 1, 失敗返回 0

注意事項:
	揹包擴容是 RO 客戶端支援的一個功能, 最大可以將角色的揹包從 100 擴容到 200.
	客戶端則封包版本號必須 >= 20181031 才支援.

--------------------------------------------------------------

*getinventorysize {<角色編號>};

用於查詢並獲取指定角色的揹包容量上限.

返回值:
	找不到角色則返回 0, 否則返回查詢到的揹包容量

--------------------------------------------------------------

*announce "<訊息文字>",<標記位>{,<字型顏色>{,<字型型別>{,<字型大小>{,<字型對齊>{,<字型垂直>{,<角色編號>}}}}}};

在 rAthena 原來的標記位基礎上, 熊貓模擬器新增了以下標記位:

標記位:
	bc_name:	在聊天欄中雙擊此訊息時會將釋出者角色名稱填寫到聊天視窗

示例程式碼:
	announce "雙擊這條文字可以私聊我喲",bc_all|bc_name;

提示資訊:
	若呼叫 announce 的指令碼沒有關聯到玩家, 那麼 bc_name 標記位將會被忽視.
	
	由於客戶端限制, 在設定上 bc_name 標記位後, 除了<字型顏色>欄位依然有效外, 其他像:
	<字型型別>,<字型大小>,<字型對齊>,<字型垂直> 等欄位將被忽視.

注意事項:
	傳送者自己雙擊聊天欄中的公告資訊是無效的, 其他玩家可以.
	此功能在 20130807 客戶端上測試有效, 更早之前的客戶端並未經過測試.

--------------------------------------------------------------

*getmapspawns "<地圖名稱>"{,<角色編號>};

用於獲取指定地圖的魔物重新整理點資訊.

地圖名稱:
	指定的地圖名稱, 比如 "prontera" 表示普隆德拉
	地圖名稱可以設定為 "this", 表示獲取當前指令碼關聯玩家所在的地圖

角色編號:
	若指定了角色編號則使用 "this" 地圖名稱時將會查詢指定角色所在地圖的魔物重新整理點資訊
	此外 @ 變數的值也將繫結記錄到該角色身上

資訊透過變數返回:
	@spawn_mobid[]		魔物編號 - 數值型陣列
	@spawn_name$[]		魔物名稱 - 字元型陣列
						使用 monster 指令的刷怪點可以設定魔物名稱,
						因此當若有指定特殊魔物名稱則優先返回特殊魔物名稱
	@spawn_num[]		重新整理魔物數量 - 數值型陣列
	@spawn_active[]		魔物當前啟用數量 - 數值型陣列
						當啟用 dynamic_mobs 時, 如果地圖沒有玩家存在則魔物不會被啟用
	@spawn_size[]		魔物體型 - 數值型陣列
						若為 -1 表示預設體型, 通常可能的返回值有:
							SZ_SMALL	-	表示小型
							SZ_MEDIUM	-	表示中型
							SZ_BIG		-	表示大型
	@spawn_isboss[]		魔物是否為 BOSS (可被 BOSS 雷達探測) - 數值型陣列
							為 0 表示普通魔物, 為 1 表示 BOSS 魔物
	@spawn_delay1[]		魔物死亡後的固定重新整理間隔 (單位為毫秒) - 數值型陣列
	@spawn_delay2[]		額外的隨機浮動重新整理間隔 (單位為毫秒) - 數值型陣列
							若配置了 delay2 則魔物死亡後的重新整理間隔為: delay1 ~ (delay1 + delay2) 之間的隨機毫秒數
	@spawn_ai[]			魔物的 AI 模式 - 數值型陣列
						若為 -1 表示預設 AI 模式, 通常可能的返回值有:
							AI_NONE
							AI_ATTACK
							AI_SPHERE
							AI_FLORA
							AI_ZANZOU
							AI_LEGION
							AI_FAW
							AI_GUILD
	@spawn_level[]		魔物等級 - 數值型陣列
							使用 monster 指令的刷怪點可以設定魔物等級,
							因此當若有指定特殊魔物等級則優先返回特殊魔物等級
	@spawn_eventname$[]	魔物死亡時觸發的事件標籤 - 字元型陣列
							若為空字串則表示沒有指定魔物死亡時觸發的事件標籤
	@spawn_mapid[]		魔物所在的地圖編號 (通常沒啥作用) - 數值型陣列
	@spawn_mapname$[]	魔物所在的地圖名稱 - 字元型陣列
	@spawn_x[]			魔物重新整理點在地圖上的 x 座標 - 數值型陣列
	@spawn_y[]			魔物重新整理點在地圖上的 y 座標 - 數值型陣列
	@spawn_xs[]			魔物重新整理點在地圖上的 xs 座標 (若為 -1 則表示沒有指定) - 數值型陣列
	@spawn_ys[]			魔物重新整理點在地圖上的 ys 座標 (若為 -1 則表示沒有指定) - 數值型陣列


	返回值及 @spawn_count 變數都會賦予查詢到的魔物刷怪點數量.

返回值:
	成功則返回找到的重新整理點數量, 失敗則返回 -1

注意事項:
	返回值陣列變數是 @ 開頭的角色變數.
	若指令在不關聯任何玩家的情況下被執行之後, 可以改用 $@ 變數來承接返回值.
	
	若您使用 $@ 變數來承接返回值內容的話,
	呼叫 getmapspawns 之後應該立刻使用變數的內容, 因為 $@ 變數是全服共享的, 
	如果呼叫完成後不立刻使用, 可能裡面填充的內容就被其他玩家呼叫 getmapspawns 替換掉了.
	
	當使用 "this" 指令的時候, 若指令碼不關聯任何玩家的話, 那麼必須指定 <角色編號>,
	否則地圖伺服器將無法理解 "this" 具體是哪一張地圖.
	
	如果您希望列出一些選單項讓玩家做選擇的話, 請使用 @ 變數承接.
	因為 @ 變數只儲存在玩家角色身上, 不會被伺服器其他玩家呼叫 getmapspawns 指令而覆蓋.
	
	與 getinventorylist 指令一樣, 請避免使用 getarraysize 來計算返回陣列的長度,
	而是使用 @spawn_count 來作為返回陣列中有效內容的最大數量, 否則可能會讀取到部分垃圾資料.

--------------------------------------------------------------

*getmobspawns <魔物編號>{,"<地圖名稱>"{,<角色編號>}};

用於查詢指定魔物在不同地圖的重新整理點資訊.

魔物編號:
	想查詢哪個魔物的重新整理點資訊, 就填寫該魔物的編號

地圖名稱:
	指定的地圖名稱, 比如 "prontera" 表示普隆德拉
	地圖名稱可以設定為 "this", 表示獲取當前指令碼關聯玩家所在的地圖

角色編號:
	若指定了角色編號則使用 "this" 地圖名稱時將會查詢指定角色所在地圖的魔物重新整理點資訊
	此外 @ 變數的值也將繫結記錄到該角色身上

資訊透過變數返回:
	@spawn_mobid[]		魔物編號 - 數值型陣列
	@spawn_name$[]		魔物名稱 - 字元型陣列
						使用 monster 指令的刷怪點可以設定魔物名稱,
						因此當若有指定特殊魔物名稱則優先返回特殊魔物名稱
	@spawn_num[]		重新整理魔物數量 - 數值型陣列
	@spawn_active[]		魔物當前啟用數量 - 數值型陣列
						當啟用 dynamic_mobs 時, 如果地圖沒有玩家存在則魔物不會被啟用
	@spawn_size[]		魔物體型 - 數值型陣列
						若為 -1 表示預設體型, 通常可能的返回值有:
							SZ_SMALL	-	表示小型
							SZ_MEDIUM	-	表示中型
							SZ_BIG		-	表示大型
	@spawn_isboss[]		魔物是否為 BOSS (可被 BOSS 雷達探測) - 數值型陣列
							為 0 表示普通魔物, 為 1 表示 BOSS 魔物
	@spawn_delay1[]		魔物死亡後的固定重新整理間隔 (單位為毫秒) - 數值型陣列
	@spawn_delay2[]		額外的隨機浮動重新整理間隔 (單位為毫秒) - 數值型陣列
							若配置了 delay2 則魔物死亡後的重新整理間隔為: delay1 ~ (delay1 + delay2) 之間的隨機毫秒數
	@spawn_ai[]			魔物的 AI 模式 - 數值型陣列
						若為 -1 表示預設 AI 模式, 通常可能的返回值有:
							AI_NONE
							AI_ATTACK
							AI_SPHERE
							AI_FLORA
							AI_ZANZOU
							AI_LEGION
							AI_FAW
							AI_GUILD
	@spawn_level[]		魔物等級 - 數值型陣列
							使用 monster 指令的刷怪點可以設定魔物等級,
							因此當若有指定特殊魔物等級則優先返回特殊魔物等級
	@spawn_eventname$[]	魔物死亡時觸發的事件標籤 - 字元型陣列
							若為空字串則表示沒有指定魔物死亡時觸發的事件標籤
	@spawn_mapid[]		魔物所在的地圖編號 (通常沒啥作用) - 數值型陣列
	@spawn_mapname$[]	魔物所在的地圖名稱 - 字元型陣列
	@spawn_x[]			魔物重新整理點在地圖上的 x 座標 - 數值型陣列
	@spawn_y[]			魔物重新整理點在地圖上的 y 座標 - 數值型陣列
	@spawn_xs[]			魔物重新整理點在地圖上的 xs 座標 (若為 -1 則表示沒有指定) - 數值型陣列
	@spawn_ys[]			魔物重新整理點在地圖上的 ys 座標 (若為 -1 則表示沒有指定) - 數值型陣列


	返回值及 @spawn_count 變數都會賦予查詢到的魔物刷怪點數量.

返回值:
	成功則返回找到的重新整理點數量, 失敗則返回 -1

注意事項:
	返回值陣列變數是 @ 開頭的角色變數.
	若指令在不關聯任何玩家的情況下被執行之後, 可以改用 $@ 變數來承接返回值.
	
	若您使用 $@ 變數來承接返回值內容的話,
	呼叫 getmobspawns 之後應該立刻使用變數的內容, 因為 $@ 變數是全服共享的, 
	如果呼叫完成後不立刻使用, 可能裡面填充的內容就被其他玩家呼叫 getmobspawns 替換掉了.
	
	當使用 "this" 指令的時候, 若指令碼不關聯任何玩家的話, 那麼必須指定 <角色編號>,
	否則地圖伺服器將無法理解 "this" 具體是哪一張地圖.
	
	如果您希望列出一些選單項讓玩家做選擇的話, 請使用 @ 變數承接.
	因為 @ 變數只儲存在玩家角色身上, 不會被伺服器其他玩家呼叫 getmobspawns 指令而覆蓋.

--------------------------------------------------------------

*getcalendartime <小時>,<分鐘>{,<月的第幾天>{,<周的第幾天>}};

獲取下次出現指定時間的 UNIX 時間戳

小時:
	可填寫值為 0 ~ 23 代表 24 小時

分鐘:
	可填寫值為 0 ~ 59 代表 60 分鐘

月的第幾天:
	可填寫值為 1 ~ 31 代表 31 天; 填寫 -1 則表示與月份無關

周的第幾天:
	SUNDAY - 週日
	MONDAY - 週一
	TUESDAY - 週二
	WEDNESDAY - 週三
	THURSDAY - 週四
	FRIDAY - 週五
	SATURDAY - 週六

如果只想使用 <每週的第幾天> 而不想使用 <每月的第幾天>,
那麼將 <每月的第幾天> 設為 -1 即可

返回值:
	成功則返回時間戳, 失敗則返回 -1

示例程式碼:
	getcalendartime(19, 00); 				// 獲取下次 19:00 的時間戳
	getcalendartime(19, 00, 6); 			// 獲取下次 6 號 19:00 的時間戳
	getcalendartime(19, 10, -1, MONDAY);	// 獲取下次 週一 19:10 的時間戳

--------------------------------------------------------------

*getskillinfo <查詢的資訊型別>,<技能編號>{,<技能等級>{,<角色編號>}};
*getskillinfo <查詢的資訊型別>,<"技能名稱">{,<技能等級>{,<角色編號>}};

獲取指定技能在技能資料庫中所配置的各項資訊

查詢的資訊型別:
	SKI_CASTTYPE
		技能施法型別
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中提供的 TargetType 進行計算得出
		
		可能的返回值:
		----------------
		CAST_GROUND				/// 地面技能
		CAST_DAMAGE				/// 傷害技能
		CAST_NODAMAGE			/// 無傷害技能
		
	SKI_NAME
		技能名稱
		
		返回值為字串型別
		該欄位的值來自 skill_db.yml 中的 Name 欄位
		通常技能名稱是英文常量, 比如狂擊的技能名稱是 SM_BASH
		
	SKI_DESCRIPTION
		技能描述
		
		返回值為字串型別
		該欄位的值來自 skill_db.yml 中的 Description 欄位
		通常技能描述是遊戲裡的技能名稱, 比如: 狂擊
		
	SKI_MAXLEVEL_IN_SKILLTREE
		指定職業的技能樹中該技能的最大等級
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入要查詢的職業程式碼
		該欄位的值來自 skill_tree.txt 中不同職業對被查詢技能所設定的最大技能等級
		
	SKI_SKILLTYPE
		技能傷害型別
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 Type 欄位
		
		可能的返回值:
		----------------
		BF_WEAPON				/// 物理攻擊型別
		BF_MAGIC				/// 魔法攻擊型別
		BF_MISC					/// 其他型別
		
	SKI_HIT
		技能命中型別
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 Hit 欄位
		
		可能的返回值:
		----------------
		DMG_SINGLE				/// (skill?)
		DMG_MULTI_HIT			/// multi-hit damage
		
	SKI_TARGETTYPE
		技能目標型別
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 TargetType 欄位
		
		可能的返回值:
		----------------
		INF_PASSIVE_SKILL		/// 
		INF_ATTACK_SKILL		/// 
		INF_GROUND_SKILL		/// 
		INF_SELF_SKILL			/// 
		INF_SUPPORT_SKILL		///
		INF_TRAP_SKILL			///
		
	SKI_ELEMENT
		技能屬性
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Element 欄位
		
		可能的返回值:
		----------------
		ELE_NEUTRAL				/// 無屬性 / 自然屬性
		ELE_WATER				/// 水屬性
		ELE_EARTH				/// 地屬性
		ELE_FIRE				/// 火屬性
		ELE_WIND				/// 風屬性
		ELE_POISON				/// 毒屬性
		ELE_HOLY				/// 聖屬性
		ELE_DARK				/// 暗屬性
		ELE_GHOST				/// 幽靈屬性
		ELE_UNDEAD				/// 不死屬性
		ELE_WEAPON				/// 使用武器的屬性
		ELE_ENDOWED				/// ??? 誰有了解的翻譯一下
		ELE_RANDOM				/// 隨機屬性
		
	SKI_DAMAGEFLAGS
		技能傷害的修正標記
		
		返回值為數值型別, 返回的是陣列長度
		用於承接返回值的陣列名稱為: @skill_damage_flags[]
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的陣列名稱為: $@skill_damage_flags[]
		該欄位的值來自 skill_db.yml 中的 DamageFlags 欄位
		
		返回值陣列中儲存是該技能啟用的傷害修正標記
		
		可能的返回值:
		----------------
		NK_NODAMAGE				/// 對應 DamageFlags 的 NoDamage 欄位
		NK_SPLASH				/// 對應 DamageFlags 的 Splash 欄位
		NK_SPLASHSPLIT			/// 對應 DamageFlags 的 SplashSplit 欄位
		NK_IGNOREATKCARD		/// 對應 DamageFlags 的 IgnoreAtkCard 欄位
		NK_IGNOREELEMENT		/// 對應 DamageFlags 的 IgnoreElement 欄位
		NK_IGNOREDEFENSE		/// 對應 DamageFlags 的 IgnoreDefense 欄位
		NK_IGNOREFLEE			/// 對應 DamageFlags 的 IgnoreFlee 欄位
		NK_IGNOREDEFCARD		/// 對應 DamageFlags 的 IgnoreDefCard 欄位
		NK_CRITICAL				/// 對應 DamageFlags 的 Critical 欄位
		NK_IGNORELONGCARD		/// 對應 DamageFlags 的 IgnoreLongCard 欄位
		
		例子:
		----------------
		以下示例程式碼是在 v1.2.4 版本調整後的最新用法
		
		getskillinfo SKI_DAMAGEFLAGS,"PR_ASPERSIO";
		
		if (@skill_damage_flags[NK_SPLASH]) {
			dispbottom "此技能擁有 Splash 傷害標誌位"; // PR_ASPERSIO 沒有這個標記位, 不會輸出這一行
		}
		if (@skill_damage_flags[NK_IGNOREELEMENT]) {
			dispbottom "此技能擁有 IgnoreElement 傷害標誌位";
		}
		
	SKI_MAXLEVEL
		技能最大等級
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 MaxLevel 欄位
		
	SKI_RANGE
		技能有效範圍 / 攻擊距離
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Range 欄位
		
	SKI_SPLASHAREA
		技能濺射範圍
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 SplashArea 欄位
		
	SKI_HITCOUNT
		技能打擊段數
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 HitCount 欄位
		
	SKI_CASTTIME
		技能可變詠唱時間 (單位為毫秒)
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 CastTime 欄位
		
	SKI_FIXEDCASTTIME
		技能固定詠唱時間 (單位為毫秒)
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 FixedCastTime 欄位
		
		僅復興後版本中擁有固定詠唱時間這個設定, 復興前版本中該類查詢返回值強制為 -1
		
	SKI_AFTERCASTACTDELAY
		技能詠唱完畢後的動作延遲時間, 別名: 技能公共延遲 (單位為毫秒)
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 AfterCastActDelay 欄位
		
	SKI_AFTERCASTWALKDELAY
		技能詠唱完畢後的移動僵直時間, 別名: 技能攻擊僵直 (單位為毫秒)
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 AfterCastWalkDelay 欄位
		
	SKI_DURATION1
		技能時間配置欄位 1 (單位為毫秒)
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Duration1 欄位
		
		不同的技能對該欄位的使用方式不同, 因此沒有明確的作用說明
		例如: 復興後的 SM_ENDURE 技能在 Duration1 中配置的值被用作 "霸體" 的效果時長
		
	SKI_DURATION2
		技能時間配置欄位 2 (單位為毫秒)
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Duration2 欄位
		
		不同的技能對該欄位的使用方式不同, 因此沒有明確的作用說明
		例如: 復興後的 PR_LEXDIVINA 技能在 Duration2 中配置的值被用作 "沉默之術" 的效果時長
		
	SKI_CASTTIMEFLAGS
		技能詠唱時間的修正標記
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 CastTimeFlags 欄位
		
		可能的返回值:
		----------------
		SKILL_CAST_IGNOREDEX		/// 標記位, 無視 DEX 帶來的修正影響
		SKILL_CAST_IGNORESTATUS		/// 標記位, 無視角色狀態 (StatusChange / 簡稱 SC) 的修正影響
		SKILL_CAST_IGNOREITEMBONUS	/// 標記位, 無視 bonus 效果調整器的修正影響
		
	SKI_CASTDELAYFLAGS
		技能延遲時間的修正標記
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 CastDelayFlags 欄位
		
		可能的返回值:
		----------------
		SKILL_CAST_IGNOREDEX		/// 標記位, 無視 DEX 帶來的修正影響
		SKILL_CAST_IGNORESTATUS		/// 標記位, 無視角色狀態 (StatusChange / 簡稱 SC) 的修正影響
		SKILL_CAST_IGNOREITEMBONUS	/// 標記位, 無視 bonus 效果調整器的修正影響
		
	SKI_CASTDEFENSEREDUCTION
		技能在詠唱期間造成施法者的防禦降低倍率
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 CastDefenseReduction 欄位
		
	SKI_FLAGS
		技能特殊標記
		
		返回值為數值型別, 返回的是陣列長度
		用於承接返回值的陣列名稱為: @skill_flags[]
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的陣列名稱為: $@skill_flags[]
		該欄位的值來自 skill_db.yml 中的 Flags 欄位
		
		返回值陣列中儲存是該技能的特殊標記
		
		可能的返回值:
		----------------
		INF2_ISQUEST				/// 這是任務技能
		INF2_ISNPC					/// 
		INF2_ISWEDDING				/// 這是結婚後才能擁有的技能
		INF2_ISSPIRIT				/// 
		INF2_ISGUILD				/// 這是公會技能
		INF2_ISSONG					/// 
		INF2_ISENSEMBLE				/// 
		INF2_ISTRAP					/// 這是陷阱技能
		INF2_TARGETSELF				/// 
		INF2_NOTARGETSELF			/// 
		INF2_PARTYONLY				/// 只能對隊伍中的成員使用
		INF2_GUILDONLY				/// 只能對公會中的成員使用
		INF2_NOTARGETENEMY			/// 
		INF2_ISAUTOSHADOWSPELL		/// 
		INF2_ISCHORUS				/// 
		INF2_IGNOREBGREDUCTION		/// 
		INF2_IGNOREGVGREDUCTION		/// 
		INF2_DISABLENEARNPC			/// 靠近部分 NPC 時禁止使用此技能
		INF2_TARGETTRAP				/// 
		INF2_IGNORELANDPROTECTOR	/// 
		INF2_ALLOWWHENHIDDEN		/// 
		INF2_ALLOWWHENPERFORMING	/// 
		INF2_TARGETEMPERIUM			/// 
		INF2_IGNOREKAGEHUMI			/// 
		INF2_ALTERRANGEVULTURE		/// 
		INF2_ALTERRANGESNAKEEYE		/// 
		INF2_ALTERRANGESHADOWJUMP	/// 
		INF2_ALTERRANGERADIUS		/// 
		INF2_ALTERRANGERESEARCHTRAP	/// 
		INF2_IGNOREHOVERING			/// 
		INF2_ALLOWONWARG			/// 
		INF2_ALLOWONMADO			/// 
		INF2_TARGETMANHOLE			/// 
		INF2_TARGETHIDDEN			/// 
		INF2_INCREASEDANCEWITHWUGDAMAGE		/// 
		INF2_IGNOREWUGBITE			/// 
		INF2_IGNOREAUTOGUARD		/// 
		INF2_IGNORECICADA			/// 
		INF2_SHOWSCALE				/// 
		
		例子:
		----------------
		以下示例程式碼是在 v1.2.4 版本調整後的最新用法
		
		getskillinfo SKI_FLAGS,"CR_DEVOTION";
		
		if (@skill_flags[INF2_NOTARGETSELF]) {
			dispbottom "此技能擁有 NoTargetSelf 標誌位";
		}
		
	SKI_CASTCANCEL
		技能在詠唱期間是否會被打斷
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 CastCancel 欄位
		
	SKI_ACTIVEINSTANCE
		技能同時存在的個數上限, 通常作用於地面技能
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 ActiveInstance 欄位
		
	SKI_KNOCKBACK
		技能擊退距離
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Knockback 欄位
		
	SKI_COOLDOWN
		技能可以被再次使用的冷卻時間 (單位為毫秒)
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Cooldown 欄位
		
	SKI_NONEARNPC_TYPE
		技能不可在哪些 NPC 附近使用
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 NoNearNPC 節點的 Type 欄位
		
		該選項的兩種情況生效:
			當 Flags 中設定了 DisableNearNpc 時生效
			當 Unit->Flag 中設定了 NoFootSet 時生效
		
		可能的返回值:
		----------------
		SKILL_NONEAR_WARPPORTAL		/// 標記位, 不能靠近傳送點附近
		SKILL_NONEAR_SHOP			/// 標記位, 不能靠近商店附近
		SKILL_NONEAR_NPC			/// 標記位, 不能靠近 NPC 附近
		SKILL_NONEAR_TOMB			/// 標記位, 不能靠近 MVP 墳墓附近
		
	SKI_NONEARNPC_ADDITIONALRANGE
		技能不可靠近的 NPC 額外距離要求
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 NoNearNPC 節點的 AdditionalRange 欄位
		
	SKI_COPYFLAGS_SKILL
		技能是否能被複制
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 CopyFlags 節點的 Skill 欄位
		
		可能的返回值:
		----------------
		0							/// 不可被複制
		SKILL_COPY_PLAGIARISM		/// 標記位, 可以被"抄襲"技能 (RG_PLAGIARISM) 複製
		SKILL_COPY_REPRODUCE		/// 標記位, 可以被"複製"技能 (SC_REPRODUCE) 複製
		
	SKI_COPYFLAGS_REMOVEREQUIREMENT
		技能被複制後, 抄襲者進行施法時是否忽略部分條件
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 CopyFlags 節點的 RemoveRequirement 欄位
		
		可能的返回值:
		----------------
		SKILL_REQ_HPCOST			/// 標記位, 無需扣減指定點數的 HP
		SKILL_REQ_SPCOST			/// 標記位, 無需扣減指定點數的 SP
		SKILL_REQ_HPRATECOST		/// 標記位, 無需扣減指定百分比的 HP
		SKILL_REQ_SPRATECOST		/// 標記位, 無需扣減指定百分比的 SP
		SKILL_REQ_MAXHPTRIGGER		/// 標記位, 無需檢查至少要有百分之多少 HP 才能施法
		SKILL_REQ_ZENYCOST			/// 標記位, 無需扣減指定數量的 Zeny
		SKILL_REQ_WEAPON			/// 標記位, 無需檢查武器符合特定型別
		SKILL_REQ_AMMO				/// 標記位, 無需檢查彈藥符合特定型別
		SKILL_REQ_STATE				/// 標記位, 無需檢查場景型別
		SKILL_REQ_STATUS			/// 標記位, 無需檢查角色狀態型別
		SKILL_REQ_SPIRITSPHERECOST	/// 標記位, 無需檢查靈氣彈數量
		SKILL_REQ_ITEMCOST			/// 標記位, 無需檢查特定物品消耗品
		SKILL_REQ_EQUIPMENT			/// 標記位, 無需檢查是否穿戴特定裝備
		
	SKI_UNIT_ID
		技能繫結的首選 Unit 子單位編號
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 Unit 節點的 Id 欄位
		
	SKI_UNIT_ALTERNATEID
		技能繫結的備選 Unit 子單位編號
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 Unit 節點的 AlternateId 欄位
		
	SKI_UNIT_LAYOUT
		技能繫結的 Unit 子單位佈局
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Unit 節點的 Layout 欄位
		
	SKI_UNIT_RANGE
		技能繫結的 Unit 子單位作用距離
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Unit 節點的 Range 欄位
		
	SKI_UNIT_INTERVAL
		技能繫結的 Unit 子單位間隔時間 (單位為毫秒)
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 Unit 節點的 Interval 欄位
		
	SKI_UNIT_TARGET
		技能繫結的 Unit 子單位作用目標
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 Unit 節點的 Target 欄位
		
		可能的返回值:
		----------------
		BCT_SELF					/// 自己
		BCT_ENEMY					/// 敵人
		BCT_PARTY					/// 隊伍成員
		BCT_GUILDALLY				/// 同盟成員, 不含公會成員
		BCT_NEUTRAL					/// 自然目標
		BCT_SAMEGUILD				/// 公會成員, 不含同盟成員
		
	SKI_UNIT_FLAG
		技能繫結的 Unit 子單位特殊標記
		
		返回值為數值型別, 返回的是陣列長度
		用於承接返回值的陣列名稱為: @skill_unit_flag[]
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的陣列名稱為: $@skill_unit_flag[]
		該欄位的值來自 skill_db.yml 中的 Unit 節點的 Flag 欄位
		
		可能的返回值:
		----------------
		UF_NOENEMY					/// If 'defunit_not_enemy' is set, the target is changed to 'friend'
		UF_NOREITERATION			/// Spell cannot be stacked
		UF_NOFOOTSET				/// Spell cannot be cast near/on targets
		UF_NOOVERLAP				/// Spell effects do not overlap
		UF_PATHCHECK				/// Only cells with a shootable path will be placed
		UF_NOPC						/// May not target players
		UF_NOMOB					/// May not target mobs
		UF_SKILL					/// May target skills
		UF_DANCE					/// Dance
		UF_ENSEMBLE					/// Duet
		UF_SONG						/// Song
		UF_DUALMODE					/// Spells should trigger both ontimer and onplace/onout/onleft effects.
		UF_NOKNOCKBACK				/// Skill unit cannot be knocked back
		UF_RANGEDSINGLEUNIT			/// hack for ranged layout, only display center
		UF_CRAZYWEEDIMMUNE			/// Immune to Crazy Weed removal
		UF_REMOVEDBYFIRERAIN		/// removed by Fire Rain
		UF_KNOCKBACKGROUP			/// knockback skill unit with its group instead of single unit
		UF_HIDDENTRAP				/// Hidden trap [Cydh]
		
		例子:
		----------------
		以下示例程式碼是在 v1.2.4 版本調整後的最新用法
		
		getskillinfo SKI_UNIT_FLAG,"RA_MAGENTATRAP";
		
		if (@skill_unit_flag[UF_NOPC]) {
			dispbottom "此技能擁有 NoPc 傷害標誌位";
		}
		
	SKI_REQUIRES_HPCOST
		技能施法條件 - 需要扣減多少點 HP 才能施法
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 HpCost 欄位
		
	SKI_REQUIRES_SPCOST
		技能施法條件 - 需要扣減多少點 SP 才能施法
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 SpCost 欄位
		
	SKI_REQUIRES_MAXHPTRIGGER
		技能施法條件 - 需要至少剩餘百分之多少的 HP 才能施法
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 MaxHpTrigger 欄位
		
	SKI_REQUIRES_HPRATECOST
		技能施法條件 - 需要扣減百分之多少的 HP 才能施法
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 HpRateCost 欄位
		
	SKI_REQUIRES_SPRATECOST
		技能施法條件 - 需要扣減百分之多少的 SP 才能施法
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 SpRateCost 欄位
		
	SKI_REQUIRES_ZENYCOST
		技能施法條件 - 需要扣減多少 Zeny 才能施法
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 ZenyCost 欄位
		
	SKI_REQUIRES_WEAPON
		技能施法條件 - 至少需要裝備符合任意一個型別的武器才能施法
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 Weapon 欄位
		
		可能的返回值:
		----------------
		0							/// 任何武器
		W_DAGGER					/// 短劍
		W_1HSWORD					/// 單手劍
		W_2HSWORD					/// 雙手劍
		W_1HSPEAR					/// 單手矛/槍/戟
		W_2HSPEAR					/// 雙手矛/槍/戟
		W_1HAXE						/// 單手斧
		W_2HAXE						/// 雙手斧
		W_MACE						/// 單手鈍器
		W_2HMACE					/// 雙手鈍器
		W_STAFF						/// 單手杖
		W_2HSTAFF					/// 雙手杖
		W_BOW						/// 弓
		W_KNUCKLE					/// 拳套
		W_MUSICAL					/// 樂器
		W_WHIP						/// 鞭子
		W_BOOK						/// 書
		W_KATAR						/// 拳刃
		W_REVOLVER					/// 左輪手槍
		W_RIFLE						/// 來復槍
		W_GATLING					/// 格林機關槍
		W_SHOTGUN					/// 散彈槍
		W_GRENADE					/// 榴彈槍
		W_HUUMA						/// 風魔
		MAX_WEAPON_TYPE				/// 該值減去 1 等於最大的武器型別值 (遍歷用)
		
		例子:
		----------------
		(返回值 & (1 << W_DAGGER)) == (1 << W_DAGGER) 成立則表示穿戴短劍才能施法
		
	SKI_REQUIRES_AMMO
		技能施法條件 - 需要裝備哪種型別的彈藥才能施法
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 Ammo 欄位
		
		可能的返回值:
		----------------
		0							/// 任何彈藥
		AMMO_ARROW					/// 箭矢
		AMMO_DAGGER					/// 短刀
		AMMO_BULLET					/// 子彈
		AMMO_SHELL					/// 炮彈
		AMMO_GRENADE				/// 榴彈
		AMMO_SHURIKEN				/// 手裡劍
		AMMO_KUNAI					/// 苦無
		AMMO_CANNONBALL				/// 加農炮彈
		AMMO_THROWWEAPON			/// 投擲物品
		MAX_AMMO_TYPE				/// 該值減去 1 等於最大的彈藥型別值 (遍歷用)
		
		例子:
		----------------
		(返回值 & (1 << AMMO_ARROW)) == (1 << AMMO_ARROW) 成立則表示使用箭矢作為彈藥才能施法
		
	SKI_REQUIRES_AMMOAMOUNT
		技能施法條件 - 需要多少個指定的彈藥才能施法
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 AmmoAmount 欄位
		
	SKI_REQUIRES_STATE
		技能施法條件 - 必須在哪些特殊的環境狀態下才能施法
		
		返回值為數值型別
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 State 欄位
		
		可能的返回值:
		----------------
		ST_NONE,					/// 
		ST_HIDDEN,					/// 
		ST_RIDING,					/// 乘騎狀態
		ST_FALCON,					/// 獵鷹狀態
		ST_CART,					/// 有手推車狀態
		ST_SHIELD,					/// 
		ST_RECOVER_WEIGHT_RATE,		/// 
		ST_MOVE_ENABLE,				/// 
		ST_WATER,					/// 站在水面上
		ST_RIDINGDRAGON,			/// 
		ST_WUG,						/// 
		ST_RIDINGWUG,				/// 
		ST_MADO,					/// 魔導機甲狀態
		ST_ELEMENTALSPIRIT,			/// 
		ST_ELEMENTALSPIRIT2,		/// 
		ST_PECO,					/// 
		ST_SUNSTANCE,				/// 
		ST_MOONSTANCE,				/// 
		ST_STARSTANCE,				/// 
		ST_UNIVERSESTANCE			/// 
		
	SKI_REQUIRES_STATUS
		技能施法條件 - 必須在哪些特殊的角色狀態下才能施法
		
		返回值為數值型別, 返回的是陣列長度
		用於承接返回值的陣列名稱為: @skill_requires_status[]
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的陣列名稱為: $@skill_requires_status[]
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 Status 欄位
		
		返回值陣列中儲存是角色狀態編號
		備註: StatusChange / 簡稱 SC / 就是用 sc_start 可以啟動的那些狀態
		
		例子:
		----------------
		.@len = getskillinfo(SKI_REQUIRES_STATUS,"MO_EXTREMITYFIST");
		dispbottom "MO_EXTREMITYFIST 要求角色有以下編號的狀態才能使用:";
		for (.@i = 0; .@i < .@len; .@i++) {
			dispbottom sprintf("第 %d 個狀態: 狀態編號 %d", .@i, @skill_requires_status[.@i]);
		}
		
	SKI_REQUIRES_SPHERECOST
		技能施法條件 - 必須擁有多少個靈氣彈才能施法
		
		返回值為數值型別
		需要在 <技能等級> 欄位中傳入技能等級
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 SphereCost 欄位
		
	SKI_REQUIRES_ITEMCOST
		技能施法條件 - 至少持有特定全部物品道具才能施法
		
		返回值為數值型別, 返回的是陣列長度
		用於承接返回值的陣列共有兩個:
			@skill_requires_itemid[]	儲存道具編號
			@skill_requires_amount[]	儲存所需的道具數量
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的兩個陣列名稱為:
			$@skill_requires_itemid[]	儲存道具編號
			$@skill_requires_amount[]	儲存所需的道具數量
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 ItemCost 欄位
		
		例子:
		----------------
		.@len = getskillinfo(SKI_REQUIRES_ITEMCOST,"KO_MAKIBISHI");
		dispbottom "KO_MAKIBISHI 要求身上有[以下全部]道具才能使用:";
		for (.@i = 0; .@i < .@len; .@i++) {
			dispbottom sprintf("第 %d 個道具: 物品編號 %d x %d 個", .@i, @skill_requires_itemid[.@i], @skill_requires_amount[.@i]);
		}
		
	SKI_REQUIRES_EQUIPMENT
		技能施法條件 - 至少需要裝備任意一件特定道具才能施法
		
		返回值為數值型別, 返回的是陣列長度
		用於承接返回值的陣列名稱為: @skill_requires_equipment[]
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的陣列名稱為: $@skill_requires_equipment[]
		該欄位的值來自 skill_db.yml 中的 Requires 節點的 Equipment 欄位
		
		返回值陣列中儲存是裝備的道具編號
		
		例子:
		----------------
		.@len = getskillinfo(SKI_REQUIRES_EQUIPMENT,"RL_P_ALTER");
		dispbottom "RL_P_ALTER 要求穿戴[以下任意一件]裝備才能使用:";
		for (.@i = 0; .@i < .@len; .@i++) {
			dispbottom sprintf("第 %d 件裝備: 物品編號 %d", .@i, @skill_requires_equipment[.@i]);
		}
	
	SKI_STATUS
		技能關聯的狀態編號
		
		返回值為數值型別
		若技能沒有關聯狀態則返回 SC_NONE
		該欄位的值來自 skill_db.yml 中的 Status 欄位

技能編號:
	傳入需要查詢的技能編號 (定義在 skill_db 中每個技能的 Id 欄位)
	例如: 劍士狂擊技能的技能編號是 5

技能名稱:
	傳入需要查詢的技能名稱 (定義在 skill_db 中每個技能的 Name 欄位)
	例如: 劍士狂擊技能的名稱是 SM_BASH (字串型別)

技能等級:
	在絕大多數情況下這個引數用來填寫要查詢的技能等級
	部分查詢型別中 <技能等級> 可能會被用作傳遞其他資訊, 例如: SKI_MAXLEVEL_IN_SKILLTREE

返回值:
	根據 <查詢的資訊型別> 的不同, 返回值的含義會有差異
	具體返回值細節已經在上文中每個不同的 <查詢的資訊型別> 說明中定義
	
	若傳遞的 <查詢的資訊型別>,<技能編號>,<"技能名稱"> 無效, 則將報錯並返回 -1

--------------------------------------------------------------

*boss_monster "<地圖名>",<x座標>,<y座標>,"<顯示名稱>",<魔物編號>,<召喚數量>{,"<死亡事件標籤>",<體型大小>,<AI>};
*boss_monster "<地圖名>",<x座標>,<y座標>,"<顯示名稱>","<魔物名稱>",<召喚數量>{,"<死亡事件標籤>",<體型大小>,<AI>};

召喚魔物並使之能被 BOSS 雷達探測 (哪怕被召喚魔物本身不是 BOSS) [人魚姬的思念]
各引數的詳細說明請直接參考 doc/script_commands.txt 中 monster 的說明.

顯示名稱:
	是指魔物被召喚出來時顯示的名字, 可以隨便起名.

魔物名稱:
	是指魔物在 mob_db 中的 AegisName

提示資訊:
	用來記錄新創造的魔物遊戲單位編號的 $@mobid[] 陣列, 在此也有作用.

--------------------------------------------------------------

*sleep3 <休眠毫秒數>;

休眠一段時間再執行後續指令碼, 與 sleep2 類似但忽略報錯 [人魚姬的思念]

休眠毫秒數:
	期望指令碼休眠多長時間 (單位為毫秒)

返回值:
	該指令無論成功與否, 都不會有返回值

注意事項:
	執行該指令時若指令碼沒有關聯玩家, 則效果等同於 sleep.
	關聯玩家情況下若執行該指令後玩家下線, 那麼休眠結束後指令碼將立刻結束 (不會繼續往下執行).

--------------------------------------------------------------

*getquesttime <任務編號>{,<想查詢的時間型別>{,<角色編號>}};

查詢角色指定任務的時間資訊.

任務編號:
	定義在 quest_db.yml 的任務 Id 值

想查詢的時間型別:
	0	-	任務的到期時間的 Unix 時間戳 (預設值)
	1	-	任務的開始時間的 Unix 時間戳
	2	-	任務的剩餘時間秒數

返回值:
	成功返回時間戳, 失敗返回 -1

注意事項:
	任務開始時間會受到 quest_db.yml 中任務時長配置的影響,
	在任務系統中唯一準確的是任務的過期時間,
	任務的開始時間是用過期時間減去 quest_db.yml 中任務時長計算出來的.
	
	任務的剩餘時間秒數的最小值為 0, 為 0 可視為任務已過期.

--------------------------------------------------------------

*query_sql_async("您的 SQL 查詢語句"{, <用於儲存第 1 列的陣列變數>{, <用於儲存第 2 列的陣列變數>{, ...}}});
*query_logsql_async("您的 SQL 查詢語句"{, <用於儲存第 1 列的陣列變數>{, <用於儲存第 2 列的陣列變數>{, ...}}});

這組指令碼指令來自與 rAthena 社群一位名為 inhyositsu 的貢獻者.
對應在 rAthena 社群的 Pull Request 地址為: https://github.com/rathena/rathena/pull/5624

以 *_async 結尾的這一組 query 指令將會以非同步的方式執行,
這意味著查詢過程中將不會阻塞指令碼執行緒 (更重要的是不會阻塞整個地圖伺服器).

如果您發起一個 SQL 查詢而不攜帶其他用來儲存返回值的引數 (例如: Insert 語句),
那麼不管 Insert 過程多麼耗時指令碼都將立刻往下執行, 而不用卡在那裡等.

如果你發起了一個類似 SELECT 並且希望獲取他返回值資料的請求,
那麼指令碼將會進入休眠狀態 (類似 sleep 指令的效果) 並且等待查詢完成後再喚醒指令碼繼續執行.

注意事項:
	多個 *_async 指令的查詢請求是序列的 (非同步不等於並行), 他不會卡死地圖伺服器,
	就使用者可能需要等待更長時間才能得到指令碼的響應.
	
	例如: 現在您設計了一個複雜的 SQL 查詢, 它的查詢會耗時 5 秒. 
	那麼如果全服 100 個玩家[同時]都去執行這個指令碼的話, 這 100 個玩家不會卡死,
	剩下的其他線上玩家也能正常遊戲, 
	但伺服器內部將需要總共 500 秒來完成這 100 個玩家的查詢請求.
	最差最差的情況下, 最後的那個玩家等到指令碼被喚醒繼續執行, 需要等待 500 秒.
	
使用提示:
	這並不是一個值得提倡使用的指令, 站在遊戲體驗的角度考慮,
	您依然應該儘可能的不要讓玩家有等待的機會.
	這個指令推薦用在一些與玩家無關的定時執行任務, 舉個不恰當的例子比如:
	
		每天凌晨 04:00 整時查詢 picklog 表看看今天撿取道具最多的玩家是誰,
		把它記下來給個稱號: 蘇乞兒
	
	之所以稱之為不恰當, 是因為你可能有其他效能更優的做法來達成類似的目的.
	
	其次執行的查詢要儘量避免鎖表, 比如剛剛的需求如果換成:
	
		每天凌晨 04:00 整時將 picklog 表中 7 天以前的記錄直接刪除掉.
	
	那他就是危險的, 因為在刪除 picklog 表的記錄時, 資料庫會鎖定 picklog 表,
	這會導致其他正常需要往這個表插入資料的查詢, 被阻塞住.
	
	上面只是舉例, 服務端對日誌表的寫入使用了 INSERT DELAYED 語法,
	可能影響不大 (未考證).
	
三級強悍的注意事項:
	能不用就不用, 用的話要知道自己在什麼, 以及可能導致的一些潛在問題.
	我僅代表個人, 主張不應該在地圖伺服器出於任何目的地執行復雜的、長耗時的 SQL 查詢,
	危險程度僅次於焊雷管鋸燈泡...

--------------------------------------------------------------

*unitspecialeffect <遊戲單位編號>,<特效編號>{,<誰能看見特效>{,<能看見特效的賬號編號>}};

使指定遊戲單位可以顯示某個特效, 類似於 specialeffect 不過它可以控制僅顯示給指定範圍的玩家目標

遊戲單位編號:
	希望給哪個遊戲單位顯示出特效, 可以是魔物、NPC、生命體、玩家等等
	只需要傳遞他們的遊戲單位編號即可

特效編號:
	遊戲特效的 Effect 編號, 可在遊戲中使用 @effect 指令來確認特效編號的視覺效果

誰能看見特效:
	用來控制特效的可見範圍, 或者說這個單位的特效應該顯示給什麼範圍的玩家

	AREA		-	傳送給可視範圍內的玩家 (預設)
	SELF		-	傳送給自己
					如果指定 <能看見特效的賬號編號> 則特效只有指定玩家看到
	PARTY_AREA	- 	傳送給以 <遊戲單位編號> 為中心可視範圍內的隊伍成員
	GUILD_AREA	- 	傳送給以 <遊戲單位編號> 為中心可視範圍內的公會成員
	BG_AREA		- 	傳送給以 <遊戲單位編號> 為中心可視範圍內的戰場陣營成員

能看見特效的賬號編號:
	當 <誰能看見特效> 等於 SELF 的時候
	可以透過此引數指定一個玩家賬號編號, 確保只有他才能看到這個特效

返回值:
	該指令無論成功與否, 都不會有返回值

注意事項:
	只有當 <遊戲單位編號> 指定的是一個玩家時, <誰能看見特效> 為 PARTY_AREA, 
	GUILD_AREA, BG_AREA 這幾個選項才會有效. 否則程式無法判斷出應該給什麼隊伍,
	公會, 戰場陣營的成員來傳送特效.

--------------------------------------------------------------

*next_dropitem_special <道具繫結型別>,<租賃時長>,<掉落光柱顏色>;

對下一個掉落到地面上的物品進行特殊設定, 支援魔物掉落道具和 makeitem 系列指令

道具繫結型別:
	-1              -   不進行特殊設定
	Bound_None      -   沒有繫結 (與 0 等價, 但更推薦用常量)
	Bound_Account   -   繫結賬號的道具, 可放個人倉庫, 全賬號共享
	Bound_Guild     -   繫結公會的道具, 可放公會倉庫與他人共享, 擁有物品的人離開公會後物品消失
	Bound_Party     -   繫結隊伍的道具, 離開隊伍後消失
	Bound_Char      -   繫結角色的道具, 不能放個人倉庫

租賃時長:
	從道具掉落時刻起開始計時, 當達到 <租賃時長> 指定的秒數之後道具將從揹包被移除
	單位為秒, 若該值非 0 則道具將會被視為租賃道具

掉落光柱顏色:
	物品掉落光柱需要客戶端版本大於等於 20180418 才支援, 舊版本客戶端沒有光柱

	-1                          -   不進行特殊設定
	DROPEFFECT_CLIENT           -   使用客戶端的物品光柱配置
	DROPEFFECT_BLUE_PILLAR      -   藍色光柱
	DROPEFFECT_YELLOW_PILLAR    -   黃色光柱
	DROPEFFECT_PURPLE_PILLAR    -   紫色光柱
	DROPEFFECT_GREEN_PILLAR     -   綠色光柱, 在 20200304 之前會變成橙色光柱
	DROPEFFECT_RED_PILLAR       -   紅色光柱

	DROPEFFECT_WHITE_PILLAR     -   白色光柱, 20200304 之後被取消
	DROPEFFECT_ORANGE_PILLAR    -   橙色光柱, 20200304 之後被綠色光柱替換

返回值:
	該指令無論成功與否, 都不會有返回值

注意事項:
	<掉落光環顏色> 的優先順序高於 makeitem 系列指令的 <canShowEffect> 欄位設定

	若希望對 makeitem / makeitem2 / makeitem3 生效, 那麼請在使用這些 makeitem 指令
	之前, 緊挨著使用 next_dropitem_special, 例如:

	next_dropitem_special -1,0,DROPEFFECT_BLUE_PILLAR;
	getmapxy(.@mapname$, .@mapx, .@mapy);
	makeitem 501,1,.@mapname$,.@mapx,.@mapy;

--------------------------------------------------------------

*logpick <日誌型別>,<揹包序號>,<要記錄的數量變化>{,<角色編號>};

在日誌資料庫的 picklog 表中生成針對指定道具的數量增減記錄

日誌型別:
	LOG_TYPE_TRADE               - 對應 picklog 表的 type 欄位值為 'T'  // (T)rade
	LOG_TYPE_VENDING             - 對應 picklog 表的 type 欄位值為 'V'  // (V)ending
	LOG_TYPE_PICKDROP_PLAYER     - 對應 picklog 表的 type 欄位值為 'P'  // (P)layer
	LOG_TYPE_PICKDROP_MONSTER    - 對應 picklog 表的 type 欄位值為 'M'  // (M)onster
	LOG_TYPE_NPC                 - 對應 picklog 表的 type 欄位值為 'S'  // NPC (S)hop
	LOG_TYPE_SCRIPT              - 對應 picklog 表的 type 欄位值為 'N'  // (N)PC Script
	LOG_TYPE_STEAL               - 對應 picklog 表的 type 欄位值為 'D'  // Steal/Snatcher
	LOG_TYPE_CONSUME             - 對應 picklog 表的 type 欄位值為 'C'  // (C)onsumed
	LOG_TYPE_PRODUCE             - 對應 picklog 表的 type 欄位值為 'O'  // Pr(O)duced/Ingredients
	LOG_TYPE_MVP                 - 對應 picklog 表的 type 欄位值為 'U'  // MVP Rewards
	LOG_TYPE_COMMAND             - 對應 picklog 表的 type 欄位值為 'A'  // (A)dmin command
	LOG_TYPE_STORAGE             - 對應 picklog 表的 type 欄位值為 'R'  // Sto(R)age
	LOG_TYPE_GSTORAGE            - 對應 picklog 表的 type 欄位值為 'G'  // (G)uild storage
	LOG_TYPE_MAIL                - 對應 picklog 表的 type 欄位值為 'E'  // (E)mail attachment
	LOG_TYPE_AUCTION             - 對應 picklog 表的 type 欄位值為 'I'  // Auct(I)on
	LOG_TYPE_BUYING_STORE        - 對應 picklog 表的 type 欄位值為 'B'  // (B)uying Store
	LOG_TYPE_LOOT                - 對應 picklog 表的 type 欄位值為 'L'  // (L)oot (consumed monster pick/drop)
	LOG_TYPE_BANK                - 對應 picklog 表的 type 欄位值為 'K'  // Ban(K) Transactions
	LOG_TYPE_OTHER               - 對應 picklog 表的 type 欄位值為 'X'  // Other
	LOG_TYPE_CASH                - 對應 picklog 表的 type 欄位值為 '$'  // Cash
	LOG_TYPE_BOUND_REMOVAL       - 對應 picklog 表的 type 欄位值為 'F'  // Removed bound items when guild/party is broken
	LOG_TYPE_ROULETTE            - 對應 picklog 表的 type 欄位值為 'Y'  // Roulette Lotter(Y)
	LOG_TYPE_MERGE_ITEM          - 對應 picklog 表的 type 欄位值為 'Z'  // Merged Item
	LOG_TYPE_QUEST               - 對應 picklog 表的 type 欄位值為 'Q'  // (Q)uest Item
	LOG_TYPE_PRIVATE_AIRSHIP     - 對應 picklog 表的 type 欄位值為 'H'  // Private Airs(H)ip
	LOG_TYPE_BARTER              - 對應 picklog 表的 type 欄位值為 'J'  // Barter Shop
	LOG_TYPE_LAPHINE             - 對應 picklog 表的 type 欄位值為 'W'  // Laphine UI

揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

要記錄的數量變化:
	通常都是 1 或者 -1, 整數表示玩家獲得了物品, 負數表示失去了物品

注意事項:
	該指令的設計目標用於在一些特殊情況下系統不會記錄 picklog 日誌時用來補充記錄使用,
	如果您不知道它的作用則建議不要隨便使用, 錯誤的使用該指令會讓 picklog 中的記錄變得
	混亂及失去可參考性.

常用場景:
	在使用 setinventoryinfo 來嘗試個改變物品的資訊是不會留下任何記錄的,
	這樣會不方便進行日誌回溯和查證.

	通常這個 logpick 指令用在 setinventoryinfo 的前後, 例如:

	.@idx = 1;                              // 舉例: 這可能是某個物品的揹包序號
	logpick LOG_TYPE_SCRIPT, .@idx, -1;     // 先記錄一個日誌表示這個物品被用掉
	setinventoryinfo .@idx,28,4;            // 將這個物品的附魔評級改成 4 級
	logpick LOG_TYPE_SCRIPT, .@idx, 1;      // 記錄一個日誌表示獲得了這個物品

--------------------------------------------------------------

*getgradeitem <物品編號>,<創造數量>,<是否已鑑定>,<精煉值>,<屬性>,<第一卡槽>,<第二卡槽>,<第三卡槽>,<第四卡槽>,<裝備的附魔評級>,<隨機屬性的編號陣列>,<隨機屬性的值陣列>,<隨機屬性的引數陣列>{,<賬號編號>};
*getgradeitem "<物品名稱>",<創造數量>,<是否已鑑定>,<精煉值>,<屬性>,<第一卡槽>,<第二卡槽>,<第三卡槽>,<第四卡槽>,<裝備的附魔評級>,<隨機屬性的編號陣列>,<隨機屬性的值陣列>,<隨機屬性的引數陣列>{,<賬號編號>};

創造帶有指定附魔評級的道具, 與 getitem4 指令碼指令完全等價.

裝備的附魔評級:
	ENCHANTGRADE_NONE	表示沒有評級
	ENCHANTGRADE_D		表示評級為 D
	ENCHANTGRADE_C		表示評級為 C
	ENCHANTGRADE_B		表示評級為 B
	ENCHANTGRADE_A		表示評級為 A

提示資訊:
	從 v1.1.17 開始 rAthena 已經實現了 getitem4 指令,
	因此 getgradeitem 降級為 getitem4 的別名, 為了指令碼通用性請儘量使用 getitem4.

--------------------------------------------------------------

*getrateidx <數值型陣列變數>;
*getrateidx <數值1>{, <數值2>{, ...<數值n>}};

隨機獲取一個數值型陣列的索引序號,
陣列中每個元素的值為權重值, 權重越高命中機率越大.

數值型陣列變數:
	存放著權重值的數值型陣列變數, 例如下面這個:
	setarray .@rate[0],2,6,3,5;

返回值:
	成功則返回隨機命中的索引序號, 失敗則報錯並中斷指令碼的執行
	索引序號將從 0 開始計算, 第一個元素為 0, 第二個元素為 1 以此類推...

用法演示:
	setarray .@item[0],501,502,503,504;
	setarray .@rate[0],2,6,3,5;
	getitem .@item[getrateidx(.@rate)],1;
	
	有 2 / (2+6+3+5) = 0.125  * 100 = 12.50% 的機率獲得紅色藥水 (501)
	有 6 / (2+6+3+5) = 0.375  * 100 = 37.50% 的機率獲得赤色藥水 (502)
	有 3 / (2+6+3+5) = 0.1875 * 100 = 18.75% 的機率獲得黃色藥水 (503)
	有 5 / (2+6+3+5) = 0.3125 * 100 = 31.25% 的機率獲得白色藥水 (504)

注意事項:
	陣列中若有某個索引的值為 0, 那麼該索引將永遠不會被命中.

--------------------------------------------------------------

*whodropitem <物品編號/"物品名稱">{,<返回的最大記錄數>{,<角色編號>}};

查詢指定道具會從哪些魔物身上掉落以及掉落的機率資訊, 與 @whodrops 管理員指令類似.
查詢後將返回按掉率降序排列的結果陣列, 結果會與 whodrops 略有差異.

物品編號/"物品名稱":
	多型別引數. 可以填寫數值型別的道具編號, 或者字串型別的道具名稱.
	推薦使用道具編號, 相較而言結果會更加準確.

返回的最大記錄數:
	可選引數, 若不指定此引數則預設返回最多 MAX_SEARCH 條記錄 (通常為 5 條記錄)
	如果選擇填寫的話, 可填寫的有效區間為 1 - 500 條記錄

資訊透過變數返回:
	@whodropitem_mob_id[]			魔物編號 - 數值型陣列
	@whodropitem_mob_jname$[]		魔物名稱 - 字元型陣列
									對應 mob_db 魔物資料庫中 JapaneseName 欄位的值
	@whodropitem_chance[]			掉落被查詢道具的機率 - 數值型陣列
									有效區間為 0 - 10000, 若為 10000 則表示 100% 掉落
	@whodropitem_count				本次查詢返回的記錄數 - 數值型變數

返回值:
	返回本次查詢返回的記錄數, 與 @whodropitem_count 等價

用法演示:
	whodropitem(512, 15);	// 查詢掉落 "蘋果" 機率最高的前 15 個魔物
	for (.@i = 0; .@i < @whodropitem_count; .@i++) {
		dispbottom(sprintf("第 %02d 條記錄 : 編號為 %d 的魔物 [%s] 掉落道具的機率為: %d", .@i + 1, @whodropitem_mob_id[.@i], @whodropitem_mob_jname$[.@i], @whodropitem_chance[.@i]));
	}

注意事項:
	返回值陣列變數是 @ 開頭的角色變數.
	若指令在不關聯任何玩家的情況下被執行之後, 可以改用 $@ 變數來承接返回值.
	
	若您使用 $@ 變數來承接返回值內容的話,
	呼叫 whodropitem 之後應該立刻使用變數的內容, 因為 $@ 變數是全服共享的, 
	如果呼叫完成後不立刻使用, 可能裡面填充的內容就被其他玩家呼叫 whodropitem 替換掉了.
	
	如果您希望列出一些選單項讓玩家做選擇的話, 請使用 @ 變數承接.
	因為 @ 變數只儲存在玩家角色身上, 不會被伺服器其他玩家呼叫 whodropitem 指令而覆蓋.
	
	與 getinventorylist 指令一樣, 請避免使用 getarraysize 來計算返回陣列的長度,
	而是使用 @whodropitem_count 來作為返回陣列中有效內容的最大數量, 否則可能會讀取到部分垃圾資料.
	
	返回的掉率將會參考等級懲罰、VIP 會員加成等結果;
	若希望排除這部分影響, 可以在不關聯玩家的情況下執行該指令.

--------------------------------------------------------------

*getbossinfo {<"地圖名稱">{,<魔物編號>{,<角色編號>}}};

查詢 BOSS 魔物重生時間及其墳墓等資訊

地圖名稱:
	指定的地圖名稱, 比如 "prontera" 表示普隆德拉
	地圖名稱可以設定為 "this", 表示獲取當前指令碼關聯玩家所在的地圖
	地圖名稱可以設定為 "all", 表示獲取全服地圖

魔物編號:
	查詢特定魔物編號的 BOSS 魔物資訊

角色編號:
	若指定了角色編號則使用 "this" 地圖名稱時將會查詢指定角色所在地圖的魔物重新整理點資訊
	此外 @ 變數的值也將繫結記錄到該角色身上

返回值:
	返回查詢到的記錄數, 查詢失敗或查無記錄則返回 0

資訊透過變數返回:
	@boss_mapid[]				BOSS 魔物所在的地圖編號 (通常沒啥作用) - 數值型陣列
	@boss_mapname$[]			BOSS 魔物所在的地圖名稱 - 字元型陣列
	@boss_x[]					BOSS 魔物所在的 x 座標 - 數值型陣列
	@boss_y[]					BOSS 魔物所在的 y 座標 - 數值型陣列
		
	@boss_gid[]					BOSS 魔物的遊戲單位編號 - 數值型陣列
								注意: 在熊貓模擬器中, 魔物重生時候的遊戲單位編號可能會變化
	@boss_spawn[]				BOSS 魔物將在多少毫秒之後重新整理復活 - 數值型陣列
								若為 0 則表示現在目標存活
	@boss_classid[]				BOSS 魔物的魔物編號 - 數值型陣列
		
	@boss_tomb_mapid[]			BOSS 墓碑所在的地圖編號 (通常沒啥作用) - 數值型陣列
	@boss_tomb_mapname$[]   	BOSS 墓碑所在的地圖名稱 - 字元型陣列
	@boss_tomb_x[]          	BOSS 墓碑所在的 x 座標 - 數值型陣列
	@boss_tomb_y[]          	BOSS 墓碑所在的 y 座標 - 數值型陣列
	
	@boss_tomb_gid[]			BOSS 墓碑的遊戲單位編號 - 數值型陣列
								若為 0 則表示還沒生成墳墓
	@boss_tomb_createtime[]		BOSS 墓碑的建立時間 (Unix 時間戳) - 數值型陣列
	
	@boss_tomb_respawnsecs[]	BOSS 魔物將在多少秒之後重新整理復活 - 數值型陣列
	@boss_tomb_respawntime[]	BOSS 魔物的復活時間 (Unix 時間戳, 讀取不到則為 -1)
	
	@boss_tomb_killer_name$[]	擊殺 BOSS 魔物的玩家名稱 - 字元型陣列
	@boss_tomb_killer_gid[]		擊殺 BOSS 魔物的玩家遊戲單位編號 - 數值型陣列
	
	@boss_count					本次查詢返回的記錄數 - 數值型變數

舉例說明:
	getbossinfo();				// 查詢全服地圖的 BOSS 魔物資訊
	getbossinfo("this");		// 查詢玩家當前地圖的 BOSS 魔物資訊
	getbossinfo("all", 1039);	// 查詢全服地圖中魔物編號為 1039 的 BOSS 魔物資訊
	getbossinfo("gef_dun01");	// 查詢 gef_dun01 地圖上的 BOSS 魔物資訊
	
注意事項:
	返回值陣列變數是 @ 開頭的角色變數.
	若指令在不關聯任何玩家的情況下被執行之後, 可以改用 $@ 變數來承接返回值.
	
	若您使用 $@ 變數來承接返回值內容的話,
	呼叫 getbossinfo 之後應該立刻使用變數的內容, 因為 $@ 變數是全服共享的, 
	如果呼叫完成後不立刻使用, 可能裡面填充的內容就被其他玩家呼叫 getbossinfo 替換掉了.
	
	當使用 "this" 指令的時候, 若指令碼不關聯任何玩家的話, 那麼必須指定 <角色編號>,
	否則地圖伺服器將無法理解 "this" 具體是哪一張地圖.
	
	如果您希望列出一些選單項讓玩家做選擇的話, 請使用 @ 變數承接.
	因為 @ 變數只儲存在玩家角色身上, 不會被伺服器其他玩家呼叫 getbossinfo 指令而覆蓋.
	
	與 getinventorylist 指令一樣, 請避免使用 getarraysize 來計算返回陣列的長度,
	而是使用 @boss_count 來作為返回陣列中有效內容的最大數量, 否則可能會讀取到部分垃圾資料.
	
	若想在地圖伺服器啟動就能獲取所有 BOSS 魔物資訊,
	請將 conf/battle/monster.conf 的 dynamic_mobs 設定為 no,
	否則由於動態生成魔物的影響, 必須在 BOSS 所在地圖有玩家前往一次之後,
	才能看到查詢到那張地圖的 BOSS 魔物資訊.

--------------------------------------------------------------

*setmapflag "<地圖名稱>",<地圖示記常量>{,<引數1>{,<引數2>{,<引數3>{,<引數4>}}}};

該指令在 rAthena 的基礎上拓展了更多的引數.
當你計劃使用 setmapflag 對熊貓拓展的地圖示記 (doc/pandas_mapflags.txt) 進行設定時,
若拓展的地圖示記需要一個或多個引數, 可以按照上面的格式進行順序書寫.

使用例子:
	// 為 prontera 設定 noattack2 標記, 禁止"生命體和魔物"使用普通攻擊.
	// 已知生命體標記位值為 8, 魔物標記位值為 2,
	// 想同時禁止他們我們需要傳遞 8 + 2 = 10 作為這個地圖示記的第一個引數.
	
	setmapflag("prontera",mf_noattack2,10);
	
	// 如果未來有某個地圖示記需要支援 4 個引數, 例如引數的值分別是 5,6,7,8 的話
	// 直接按順序書寫就行, 例如:
	
	setmapflag("prontera",mf_something,5,6,7,8);

--------------------------------------------------------------

*setoptionbyidx <揹包序號>,<隨機屬性的編號陣列>,<隨機屬性的值陣列>,<隨機屬性的引數陣列>{,<角色編號>};
*setoptionbypos <EQI裝備位置>,<隨機屬性的編號陣列>,<隨機屬性的值陣列>,<隨機屬性的引數陣列>{,<角色編號>};

給指定道具設定隨機屬性 (Random Option) 並且能夠留下日誌紀錄

揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

EQI裝備位置:
	是指 EQI_* 開頭的位置常量, 可參考 doc/script_commands.txt

隨機屬性的編號陣列:
	同 getitem3 的 <RandomIDArray> 引數等價

隨機屬性的值陣列:
	同 getitem3 的 <RandomValueArray> 引數等價

隨機屬性的引數陣列:
	同 getitem3 的 <RandomParamArray> 引數等價

返回值:
	操作成功則返回 1, 操作失敗則返回 0

注意事項:
	使用該組指令操作目標道具時, 會在日誌中留下目標道具被指令碼刪除後重新獲得兩條記錄.

--------------------------------------------------------------

*resetoptionbyidx <揹包序號>{,<角色編號>};
*resetoptionbypos <EQI裝備位置>{,<角色編號>};

清空指定道具的隨機屬性 (Random Option) 並且能夠留下日誌紀錄

揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

EQI裝備位置:
	是指 EQI_* 開頭的位置常量, 可參考 doc/script_commands.txt

返回值:
	操作成功則返回 1, 操作失敗則返回 0

注意事項:
	使用該組指令操作目標道具時, 會在日誌中留下目標道具被指令碼刪除後重新獲得兩條記錄.

--------------------------------------------------------------

*instance_srcmapname <"副本地圖名稱">{,<副本編號>};

將副本地圖名稱轉換成對應的原始地圖名稱.
原始地圖名稱是指配置在 db\{pre-}re\instance_db.yml 中的地圖名.

副本地圖名稱:
	是指玩家處於副本地圖中使用 strcharinfo(3) 直接拿到的類似:
	0693#000001 的地圖名稱

副本編號:
	副本中的 NPC 呼叫該指令時可以不傳遞副本編號,
	副本外的 NPC 呼叫該指令是應該使用 instance_id 指令來獲得正確的副本編號.

返回值:
	成功返回原始地圖名, 失敗返回空字串

提示資訊:
	- 使用 instance_mapname    可將原始地圖名 1@orcs 轉換成副本地圖名 0693#000001
	- 使用 instance_srcmapname 可將副本地圖名 0693#000001 轉換成原始地圖名 1@orcs

--------------------------------------------------------------

*instance_add_map <"源地圖名稱">{,<放棄複製源地圖上的 NPC 到副本中>{,<放棄複製源地圖上的地圖示記>{,<副本編號>}}};

為指定的副本動態新增任意需要的映象地圖.

源地圖名稱:
	想將哪張地圖新增到副本中, 就填寫它的地圖名稱

放棄複製源地圖上的 NPC 到副本中:
	1 - 放棄複製 (預設)
	0 - 複製

放棄複製源地圖上的地圖示記:
	1 - 放棄複製 (預設)
	0 - 複製

副本編號:
	若不提供則自動讀取當前呼叫 NPC 所在的副本編號

返回值:
	操作成功則返回 1, 失敗則返回小於等於 0 的錯誤碼
	
	 0 - 提供的副本編號無效 (負數或者副本已被銷燬)
	-1 - 提供的源地圖名稱無效, 無法複製地圖
	-2 - 提供的源地圖隸屬於副本, 隸屬於副本的地圖不能用作於源地圖
	-3 - 提供的源地圖已經在目標副本中存在映象, 無需重複新增
	-4 - 複製映象地圖時候發生了錯誤

注意事項:
	同一張地圖只能被新增到副本中一次, 重複新增的話會失敗

--------------------------------------------------------------

*instance_del_map <"源地圖名稱"{,<副本編號>}>;

刪除副本中以指定地圖為藍本的映象地圖.

源地圖名稱:
	想刪除哪張地圖的映象地圖, 就填寫它的地圖名稱
	呼叫 instance_add_map 的時候填寫的是 "prontera" 那麼這裡也依然填寫 "prontera"

副本編號:
	若不提供則自動讀取當前呼叫 NPC 所在的副本編號

返回值:
	操作成功則返回 1, 失敗則返回小於等於 0 的錯誤碼
	
	 0 - 提供的副本編號無效 (負數或者副本已被銷燬)
	-1 - 提供的源地圖名稱無效, 無法複製地圖
	-2 - 提供的源地圖並沒有任何映象地圖存在於指定的副本中, 無需刪除

注意事項:
	以這種方式移除的映象地圖, 上面的映象 NPC 將不會觸發 OnInstanceDestroy 事件

--------------------------------------------------------------

*instance_has_map <"源地圖名稱">{,<副本編號>};

判斷指定副本中是否包含指定地圖的映象地圖.

源地圖名稱:
	填寫想檢查的源地圖名稱

副本編號:
	若不提供則自動讀取當前呼叫 NPC 所在的副本編號

返回值:
	存在返回 1, 不存在返回 0, 其他錯誤返回小於 0 的錯誤碼
	
	-1 - 提供的副本編號無效 (負數或者副本已被銷燬)
	-2 - 提供的源地圖名稱無效

--------------------------------------------------------------

*selectitem <物品編號的數值型陣列>{,<角色編號>};
*selectitem <"物品編號以冒號分隔的字串">{,<角色編號>};

生成物品選擇對話方塊, 讓玩家從指定的物品清單中選擇一個物品

物品編號的數值型陣列:
	包含有效物品編號的數值型陣列

	setarray .@itemlist[0],501,502;
	.@ret = selectitem(.@itemlist);
	dispbottom "selectitem ret = " + .@ret;

物品編號以冒號分隔的字串:
	該方式支援物品的 AegisName, 物品之間以 : 冒號進行分隔

	.@ret = selectitem("501:502:Kafra_Card");
	dispbottom "selectitem ret = " + .@ret;

返回值:
	成功則返回玩家選擇的物品編號, 失敗則返回 0, 玩家取消返回 -1

相容設計:
	出於相容市面上指令碼的考慮, 該指令的別名為 itemlist.

--------------------------------------------------------------

*selectskill <技能編號的數值型陣列>{,<角色編號>};
*selectskill <"技能編號以冒號分隔的字串">{,<角色編號>};

生成技能選擇對話方塊, 讓玩家從指定的技能清單中選擇一個技能

技能編號的數值型陣列:
	包含有效技能編號的數值型陣列

	setarray .@skilllist[0],5,530;
	.@ret = selectskill(.@skilllist);
	dispbottom "selectskill ret = " + .@ret;

技能編號以冒號分隔的字串:
	該方式支援技能的 AegisName, 技能之間以 : 冒號進行分隔

	.@ret = selectskill("5:530:SA_COMA");
	dispbottom "selectskill ret = " + .@ret;

返回值:
	成功則返回玩家選擇的技能編號, 失敗則返回 0, 玩家取消返回 -1

相容設計:
	出於相容市面上指令碼的考慮, 該指令的別名為 skilllist.

--------------------------------------------------------------

*item_enchant <附魔資料編號>{,<角色編號>};

開啟附魔互動介面並載入指定的附魔資料.
該指令在 rAthena 的基礎上拓展了返回值以便判斷失敗原因.

附魔資料編號:
	定義在 db/re/item_enchant.yml 附魔資料庫中的 Id 欄位的值

返回值:
	0	指定的角色或玩家不存在
	1	執行成功
	-1	揹包負重量超過 70%, 無法開啟附魔互動介面
	-2	指定的附魔資料編號無效 (不存在於 item_enchant.yml 資料庫中)

注意事項:
	此功能只有客戶端版本大於等於 2021-11-03 才支援.

	位於 db/re/item_enchant.yml 的附魔資料必須和客戶端
	data\luafiles514\lua files\enchant\enchantlist.lub 的內容對應

--------------------------------------------------------------

*npcshopfilter "<商店 NPC 名稱>"{,<關聯標記位>};

接管 NPC 商店的部分流程，將其轉移到當前執行中的 NPC 進行處理

商店 NPC 名稱:
	將指定的商店 NPC 關聯到當前正在執行的指令碼

關聯標記位:
	1	建立 NPC 商店與當前指令碼的關聯 (預設值)
	0	解除 NPC 商店與當前指令碼的關聯

返回值:
	操作成功則返回 1, 操作失敗則返回 0

OnListSellItem:
	當關聯到的商店即將列出玩家揹包中即將呈現在出售視窗的道具時,
	將會觸發此標籤. 該標籤會返回攜帶以下引數:
	
	@prepare_list_idx		即將列出的道具揹包序號
	@prepare_list_result	是否允許列出, 以下為該變數的有效值:
							LIST_RESULT_DEFAULT		- 不進行任何流程干預
							LIST_RESULT_HIDE		- 禁止道具在出售列表中列出
							LIST_RESULT_SHOW		- 允許道具在出售列表中列出 (謹慎使用, 會繞過全部僅售限制)

注意事項:
	在呼叫 callshop 之前使用 npcshopfilter.
	
	將 @prepare_list_result 設定為 LIST_RESULT_SHOW 的時候需要特別注意,
	這會繞過任何一切禁止出售物品的限制.

使用例子:
	
-	shop	TestSellShop#Example	-1,2211:-1

prontera,150,150,3	script	tester	123,{
	// 若想使用 OnListSellItem 標籤,
	// 那麼需要在 callshop 之前先使用 npcshopfilter
	//
	// 由於 npcshopfilter 指令是在 tester 這個 NPC 中執行的
	// 因此 TestSellShop#Example 的流程處理將交給 tester 來執行
	// 例如: OnListSellItem 觸發的將會是 tester::OnListSellItem
	npcshopfilter "TestSellShop#Example";
	
	// 開啟商店的出售介面
	callshop "TestSellShop#Example",2;
end;
OnListSellItem:
	// 使用 getinventoryinfo 根據 @prepare_list_idx 揹包序號獲取物品編號
	if (getinventoryinfo(@prepare_list_idx,0) == 1101) {
		// 若物品編號是 1101 則設定為: LIST_RESULT_HIDE 表示不在出售視窗中列出
		@prepare_list_result = LIST_RESULT_HIDE;
	}
end;
}

--------------------------------------------------------------

*refineui_result <道具揹包序號>,<動畫型別>,<精煉等級>;

調整精煉互動介面的返回結果並修改物品精煉等級.

動畫型別:
	0 - 精煉成功
	1 - 精煉失敗, 裝備消失
	2 - 精煉失敗, 精煉降級
	3 - 精煉失敗, 但是被鐵匠的祝福保級

精煉等級:
	無論 <動畫型別> 中的動畫是精煉成功或失敗,
	都會通知將物品精煉等級直接設定為 <精煉等級> 所指定的值.
	
注意事項:
	該指令僅可在 OnPCRefineUIFilter 事件中使用.
	
	成功使用該指令之後將直接打斷後續的精煉處理流程,
	可以理解為它隱含的執行了 processhalt 指令.

	該指令不消耗任何道具, 請使用 delitem 刪除精煉材料.

--------------------------------------------------------------

*getpvpinfo <查詢的資訊型別>{,<角色編號>};

獲取玩家的 PVP 資訊, 比如當前排名以及堅持時間等

查詢的資訊型別:
	PVPINFO_POINT				當前的 PVP 積分
								玩家 PVP 剛開始的時候預設都是 5 積分,
								殺死一人得 1 分, 被殺死扣 5 分,
								如果分數小於 0 分則將玩家送回出生點
	
	PVPINFO_WON					當前玩家的 PVP 獲勝次數 (殺死多少人)
	
	PVPINFO_LOST				當前玩家的 PVP 死亡次數 (被殺死多少次)
	
	PVPINFO_RANK				當前的 PVP 排名
								也就是 PVP 地圖右下角 1/2 指示器中的 1
	
	PVPINFO_TOTAL_USERS			當前地圖中的玩家總數
								也就是 PVP 地圖右下角 1/2 指示器中的 2
	
	PVPINFO_ALIVE_TIME			玩家在 PVP 地圖中的本輪存活秒數
								該計數器會在玩家存活期間自動不斷增加,
								死亡後該值將清零並將數值轉存到 PVPINFO_LAST_ALIVE_TIME.
								重新進入地圖 (例如下線重新登入), 該值會清零.
	
	PVPINFO_LAST_ALIVE_TIME		玩家在 PVP 地圖中上一次存活秒數
								在 PVP 中第一次死亡的時候該值才會被記錄
								重新進入地圖 (例如下線重新登入), 該值會清零.

	PVPINFO_MAX_ALIVE_TIME		玩家在 PVP 地圖中最長的一次的存活秒數
								若 PVPINFO_MAX_ALIVE_TIME 小於 PVPINFO_ALIVE_TIME,
								那麼該值將自動等於 PVPINFO_ALIVE_TIME.
								重新進入地圖 (例如下線重新登入), 該值會清零.
	
	PVPINFO_TOP_TIME			玩家在 PVP 地圖中本輪獲得第一名堅持的秒數
								必須排名第一併且角色處於存活狀態, 該值才會增加.
								失去第一名時該值將清零並將數值轉存到 PVPINFO_LAST_TOP_TIME.
								重新進入地圖 (例如下線重新登入), 該值會清零.

	PVPINFO_LAST_TOP_TIME		玩家在 PVP 地圖中上一次獲得第一名時堅持的秒數
								在 PVP 中獲得了失去了第一名的時候該值才會被記錄.
								重新進入地圖 (例如下線重新登入), 該值會清零.

	PVPINFO_MAX_TOP_TIME		玩家在 PVP 地圖中最長的一次的獲得第一名時堅持的秒數
								若 PVPINFO_MAX_TOP_TIME 小於 PVPINFO_TOP_TIME,
								那麼該值將自動等於 PVPINFO_TOP_TIME.
								重新進入地圖 (例如下線重新登入), 該值會清零.

返回值:
	發生錯誤將返回 -1, 否則返回查詢的的資訊

--------------------------------------------------------------

*getpvprank {<"地圖名稱">{,<角色編號>}};

獲取指定 PVP 地圖上的排行榜資訊

地圖名稱:
	指定的地圖名稱, 比如 "prontera" 表示普隆德拉
	若不攜帶此引數或將地圖名稱設定為 "this", 表示獲取當前指令碼關聯玩家所在的地圖

返回值:
	返回查詢到的記錄數, 查詢失敗或查無記錄則返回 0

資訊透過變數返回:
	@rank_aid[]					玩家的賬號編號
	@rank_cid[]					玩家的角色編號
	@rank_count					排行榜中的玩家角色數量

提示資訊:
	第一名的玩家存放在陣列的第 0 個元素,
	第二名存放在陣列的第 1 個元素, 以此類推...

注意事項:
	若指定的地圖不是 PVP 地圖或沒有開啟 PVP 模式,
	那麼獲取到的資料將為空, 這種情況下 getpvprank 會返回失敗

	返回值陣列變數是 @ 開頭的角色變數.
	若指令在不關聯任何玩家的情況下被執行之後, 可以改用 $@ 變數來承接返回值.
	
	若您使用 $@ 變數來承接返回值內容的話,
	呼叫 getpvprank 之後應該立刻使用變數的內容, 因為 $@ 變數是全服共享的, 
	如果呼叫完成後不立刻使用, 可能裡面填充的內容就被其他玩家呼叫 getpvprank 替換掉了.
	
	當使用 "this" 指令的時候, 若指令碼不關聯任何玩家的話, 那麼必須指定 <角色編號>,
	否則地圖伺服器將無法理解 "this" 具體是哪一張地圖.
	
	如果您希望列出一些選單項讓玩家做選擇的話, 請使用 @ 變數承接.
	因為 @ 變數只儲存在玩家角色身上, 不會被伺服器其他玩家呼叫 getpvprank 指令而覆蓋.
	
	與 getinventorylist 指令一樣, 請避免使用 getarraysize 來計算返回陣列的長度,
	而是使用 @rank_count 來作為返回陣列中有效內容的最大數量, 否則可能會讀取到部分垃圾資料.

--------------------------------------------------------------

*sethiddenfromsight <想要隱藏的目標>,<開啟隱藏>{,<角色編號>};

隱藏玩家的視野中指定的單位或者特效

想要隱藏的目標:
	HIDE_MOB_NORMAL			- 普通魔物
	HIDE_MOB_MVP			- MVP 魔物
	HIDE_MOB_MINI			- MiniBOSS 魔物
	HIDE_MOB_ALL			- 全部魔物

	HIDE_PC_FRIEND			- 好友
	HIDE_PC_PARTY			- 隊友
	HIDE_PC_GUILD			- 公會成員
	HIDE_PC_GUILD_ALLY		- 同盟成員
	HIDE_PC_FRIENDLY		- 友好單位 (好友 + 隊友 + 公會成員 + 同盟成員)
	HIDE_PC_STRANGER		- 陌生單位 (非友好單位)
	HIDE_PC_ALL				- 全部玩家

	HIDE_PET_MIND			- 自己的寵物
	HIDE_PET_OTHER			- 其他玩家的寵物
	HIDE_PET_ALL			- 全部寵物
	
	HIDE_HOM_MIND			- 自己的生命體
	HIDE_HOM_OTHER			- 其他玩家的生命體
	HIDE_HOM_ALL			- 全部生命體

	HIDE_ELEM_MIND			- 自己的元素精靈
	HIDE_ELEM_OTHER			- 其他玩家的元素精靈
	HIDE_ELEM_ALL			- 全部元素精靈

	HIDE_MER_MIND			- 自己的傭兵
	HIDE_MER_OTHER			- 其他玩家的傭兵
	HIDE_MER_ALL			- 全部傭兵
	
	HIDE_HAT_EFFECT_MIND	- 自己的頭飾特效 (Hat Effect)
	HIDE_HAT_EFFECT_OTHER	- 其他玩家的頭飾特效 (Hat Effect)
	HIDE_HAT_EFFECT_ALL		- 全部單位的頭飾特效 (Hat Effect)
	
	HIDE_LOOK_TOP_MIND		- 自己的頭飾(上)外觀
	HIDE_LOOK_MID_MIND		- 自己的頭飾(中)外觀
	HIDE_LOOK_BOTTOM_MIND	- 自己的頭飾(下)外觀
	HIDE_LOOK_ROBE_MIND		- 自己的披肩外觀
	HIDE_LOOK_ALL_MIND		- 自己的全部外觀 (不含頭飾特效)
	
	HIDE_LOOK_TOP_OTHER		- 其它玩家的頭飾(上)外觀
	HIDE_LOOK_MID_OTHER		- 其它玩家的頭飾(中)外觀
	HIDE_LOOK_BOTTOM_OTHER	- 其它玩家的頭飾(下)外觀
	HIDE_LOOK_ROBE_OTHER	- 其它玩家的披肩外觀
	HIDE_LOOK_ALL_OTHER		- 其它玩家的全部外觀 (不含頭飾特效)
	
	HIDE_LOOK_ALL			- 自己和其他玩家的全部外觀


開啟隱藏:
	設定為 true 表示隱藏; 設定為 false 表示不隱藏

使用例子:
	若希望地圖上只顯示 MVP 魔物, 你可以用以下方式實現:
	
		// 首先隱藏所有魔物
		sethiddenfromsight HIDE_MOB_ALL, true;
		
		// 關閉 MVP 魔物的隱藏, 這樣它就顯示了出來
		sethiddenfromsight HIDE_MOB_MVP, false;

	若希望地圖上只顯示 MVP 魔物和 MiniBOSS 魔物, 那麼:
	
		// 首先隱藏所有魔物
		sethiddenfromsight HIDE_MOB_ALL, true;
		
		// 關閉 MVP 和 MiniBOSS 魔物的隱藏, 這樣它們就顯示了出來
		sethiddenfromsight HIDE_MOB_MVP|HIDE_MOB_MINI, false;

返回值:
	無論成功失敗都不會有返回值

注意事項:
	當玩家隱藏了魔物之後可能還在持續遭到魔物的攻擊,
	正常情況下由魔物攻擊導致的僵直雖然不會在畫面中及時顯示出來,
	但會導致玩家在後續移動過程中不斷被服務端修正位置,
	出現類似擊退的拖曳情況, 這是正常現象.
	
	未來有時間我們再研究一下這個問題是否可以得到解決.
	
	隱藏自己的傭兵和生命體的話會導致客戶端無法識別到他們而
	無法執行客戶端的 AI 邏輯. 自己的傭兵和生命體在不可見狀態下
	不能跟著你移動 (只會在離你太遠的時候瞬移跟上去),
	也無法在你看不到的情況下幫你打架.
	
	在使用 HIDE_LOOK_* 系列目標時, 如果遇到頭飾是組合位置,
	那麼只需針對他們組合位置中第一個位置即可, 例如:
	
	- 組合位置為: 上中,   第一個位置是 "上", 用 HIDE_LOOK_TOP_* 處理它
	- 組合位置為: 中下,   第一個位置是 "中", 用 HIDE_LOOK_MID_* 處理它
	- 組合位置為: 上下,   第一個位置是 "上", 用 HIDE_LOOK_TOP_* 處理它
	- 組合位置為: 上中下, 第一個位置是 "上", 用 HIDE_LOOK_TOP_* 處理它
	
	從 2024 年的第一個專業版開始, 該項的值會被持久化儲存到資料庫,
	儲存在 char 表的 view_control 欄位, 因此您無需再使用變數進行儲存.

--------------------------------------------------------------

*gethiddenfromsight {<角色編號>};

獲取當前玩家已經隱藏的單位或者特效

使用例子:
	.@flag = gethiddenfromsight();
	if (.@flag & HIDE_MOB_MVP) {
		dispbottom "玩家隱藏了 MVP 魔物";
	}
	else {
		dispbottom "玩家沒有隱藏 MVP 魔物";
	}

返回值:
	當前玩家已經隱藏的單位或者特效, 若返回 0 表示什麼都不隱藏

--------------------------------------------------------------

*setdialogsize <寬度>,<高度>;

用於設定 NPC 對話方塊的尺寸, 單位為: 畫素 (px)
該指令只在客戶端封包版本大於等於 20220504 的時候有效.

使用例子:
	mes "視窗尺寸為 400 x 200 畫素";
	setdialogsize(400,200);
	next;
	mes "視窗尺寸為 500 x 300 畫素";
	setdialogsize(500,300);
	close;

返回值:
	成功沒有返回值, 失敗會報錯

注意事項:
	必須在對話方塊存在的時候調整尺寸才會生效,
	這也是為什麼上面例子先 mes 再 setdialogsize 的原因.

--------------------------------------------------------------

*setdialogpospercent <X百分比>,<Y百分比>;

用於設定 NPC 對話方塊的百分比位置
該指令只在客戶端封包版本大於等於 20220504 的時候有效.

使用例子:
	mes "我在 50% x 50% 的位置";
	setdialogpospercent(50,50);
	next;
	mes "我在 90% x 90% 的位置";
	setdialogpospercent(90,90);
	next;
	mes "我在 100% x 100% 的位置";
	setdialogpospercent(100,100);
	close;

返回值:
	成功沒有返回值, 失敗會報錯

注意事項:
	必須在對話方塊存在的時候調整位置才會生效,
	這也是為什麼上面例子先 mes 再 setdialogpospercent 的原因.

	使用 50,50 表示視窗居中
	使用 0,0 表示視窗緊挨著左上角
	使用 100,100 表示視窗緊挨著右下角

--------------------------------------------------------------

*setdialogpos <X座標>,<Y座標>;

用於設定 NPC 對話方塊的絕對位置座標, 單位為: 畫素 (px)
該指令只在客戶端封包版本大於等於 20220504 的時候有效.

使用例子:
	mes "我在距離左上角 100 x 100 畫素的位置";
	setdialogpos(100,100);
	next;
	mes "我在距離左上角 300 x 200 畫素的位置";
	setdialogpos(300,200);
	close;

返回值:
	成功沒有返回值, 失敗會報錯

注意事項:
	必須在對話方塊存在的時候調整位置才會生效,
	這也是為什麼上面例子先 mes 再 setdialogpos 的原因.
	
	座標原點 0,0 在遊戲視窗左上角的位置 (不含視窗標題欄).

--------------------------------------------------------------

*setdialogalign <對齊方式>;

用於設定 NPC 對話方塊中文字的垂直或水平對齊方式
該指令只在客戶端封包版本大於等於 20210203 的時候有效.

對齊方式:
	DIALOG_ALIGN_LEFT       水平(橫向)左側
	DIALOG_ALIGN_RIGHT      水平(橫向)右側
	DIALOG_ALIGN_CENTER     水平(橫向)居中

	DIALOG_ALIGN_TOP        垂直(縱向)頂部
	DIALOG_ALIGN_MIDDLE     垂直(縱向)中間
	DIALOG_ALIGN_BOTTOM     垂直(縱向)底部
	
	水平規則和垂直規則可以各設定一個, 它們將組合生效

使用例子:
	setdialogalign(DIALOG_ALIGN_RIGHT);
	mes("水平右側");
	next;
	
	setdialogalign(DIALOG_ALIGN_CENTER);
	mes("水平居中");
	next;
	
	setdialogalign(DIALOG_ALIGN_RIGHT);
	setdialogalign(DIALOG_ALIGN_BOTTOM);
	mes("水平右側 + 垂直底部");
	next;
	
	setdialogalign(DIALOG_ALIGN_CENTER);
	setdialogalign(DIALOG_ALIGN_MIDDLE);
	mes("水平居中 + 垂直中間");
	close;

返回值:
	成功沒有返回值, 失敗會報錯

注意事項:
	- 必須在 mes 之前使用才有效
	- 在點選 next 或 close 後對齊規則會清空
	- 水平靠右的時候無法頂到最右側 (測於 20220406 客戶端)
	- 在一段對話若有多個水平 setdialogalign 將只有第一個生效
	- 在一段對話若有多個垂直 setdialogalign 將只有第一個生效

--------------------------------------------------------------

*getlinexy <起點 x 座標>,<起點 y 座標>,<終點 x 座標>,<終點 y 座標>,<用於接收 x 座標的陣列>,<用於接收 y 座標的陣列>;

獲得指定直線上的所有座標點 [人魚姬的思念]

用於接收 x 座標的陣列:
	數值型陣列, 用於承接返回座標中的 x 座標

用於接收 y 座標的陣列:
	數值型陣列, 用於承接返回座標中的 y 座標

使用例子:
	// 首都中央花壇下繪製個 \ (召喚綠草)
	.@cnt = getlinexy(158,177,153,182,$@retX,$@retY);
	for (.@i = 0; .@i < .@cnt; .@i++) {
		monster "prontera", $@retX[.@i], $@retY[.@i], "--ja--", 1080, 1;
	}
	
	// 首都中央花壇下繪製個 / (召喚綠草)
	.@cnt = getlinexy(158,182,153,177,$@retX,$@retY);
	for (.@i = 0; .@i < .@cnt; .@i++) {
		monster "prontera", $@retX[.@i], $@retY[.@i], "--ja--", 1080, 1;
	}

返回值:
	成功返回座標個數, 失敗返回 -1

注意事項:
	若使用該指令的時候指令碼沒有關聯到某一個具體得玩家,
	那麼接收陣列只能用與玩家無關的變數型別, 例如可以使用: $@ 來承接

--------------------------------------------------------------

*getcirclexy <圓心 x 座標>,<圓心 y 座標>,<半徑>,<用於接收 x 座標的陣列>,<用於接收 y 座標的陣列>;

獲得指定圓心和半徑的圓的邊長上的所有座標點 [人魚姬的思念]

用於接收 x 座標的陣列:
	數值型陣列, 用於承接返回座標中的 x 座標

用於接收 y 座標的陣列:
	數值型陣列, 用於承接返回座標中的 y 座標

使用例子:
    .@cnt = getcirclexy(156,164,1,$@retX,$@retY);
    for (.@i = 0; .@i < .@cnt; .@i++) {
        monster "prontera", $@retX[.@i], $@retY[.@i], "--ja--", 1080, 1;
    }

    .@cnt = getcirclexy(156,164,3,$@retX,$@retY);
    for (.@i = 0; .@i < .@cnt; .@i++) {
        monster "prontera", $@retX[.@i], $@retY[.@i], "--ja--", 1080, 1;
    }

返回值:
	成功返回座標個數, 失敗返回 -1

注意事項:
	若使用該指令的時候指令碼沒有關聯到某一個具體得玩家,
	那麼接收陣列只能用與玩家無關的變數型別, 例如可以使用: $@ 來承接
	
	半徑不能小於等於 0, 否則將報錯並返回 -1

--------------------------------------------------------------

*getpetidfromegg <寵物蛋物品編號/"寵物蛋物品名稱">;

根據寵物蛋編號查詢與之對應的魔物編號

寵物蛋物品編號/"寵物蛋物品名稱":
	多型別引數. 可以填寫數值型別的道具編號, 或者字串型別的道具名稱.
	推薦使用道具編號, 相較而言結果會更加準確.

返回值:
	成功返回魔物編號, 失敗返回 0

--------------------------------------------------------------

*openrunetableui {<角色編號>};

開啟符文石碑互動介面. 該指令隸屬於 FEATURE-1012 功能包.

注意事項:
	此功能只有客戶端版本大於等於 2023-08-02 才支援.

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*putidxintostorage <揹包序號>,<存入數量>{,<倉庫編號>{,<是否觸發事件>{,<角色編號>}}};
*putidxintocart <揹包序號,<存入數量>{,<是否觸發事件>{,<角色編號>}}};
*putidxintoguildstorage <揹包序號>,<存入數量>{,<是否觸發事件>{,<角色編號>}}};

將指定揹包序號的道具存入手推車或者個人倉庫、拓展倉庫、公會倉庫

揹包序號:
	可以透過 getinventorylist 指令碼指令的 @inventorylist_idx[] 陣列來獲得.

倉庫編號:
	0 - 個人倉庫 (每個玩家都會有的預設倉庫)
	X - 擴充倉庫 (其他非 0 的定義在 conf/inter_athena.yml 中的有效倉庫編號)

是否觸發事件:
	預設為觸發, 這裡的事件是指:
	- 使用 putidxintocart 時是否觸發 OnPCCartAddFilter 過濾器事件
	- 使用 putidxintostorage / putidxintoguildstorage時是否觸發 OnPCStorageAddFilter 過濾器事件

返回值:
	成功返回 1, 失敗返回小於等於 0 的錯誤程式碼
	
	  0 - 無法識別的倉庫型別, 或者開啟目標倉庫失敗了
	 -1 - 無法關聯到指定的角色編號
	 -2 - 提供的揹包序號不在合理的有效範圍內
	 -3 - 存入數量不正確 (負數或者超過揹包中實際持有的上限)
	 -4 - 揹包序號指定的道具無效
	 -5 - 已穿戴或登記為第二套快速切換裝備的道具不能存入
	 -6 - 已經孵化的寵物蛋不能被存入
	 -7 - 沒有目標倉庫的存入許可權 (例如計劃存入公會倉庫, 但會長沒給你許可權)
	 -8 - 超過目標倉庫/手推車的儲存限制 (繫結道具、禁止存倉道具、堆疊限制、負重限制、空間限制等)
	 -9 - 準備擺攤或正在擺攤時不能將道具存入手推車
	-10 - 公會倉庫被公會成員開啟或鎖定時, 不能存入道具
	-11 - 某個倉庫處於開啟狀態, 需要先關閉倉庫才能繼續使用

注意事項:
	- 穿戴中的裝備不能存入, 將返回失敗
	- 被註冊為第二套快捷切換裝備的道具不能存入, 將返回失敗
	- 已經被孵化的寵物蛋不能存入, 將返回失敗

--------------------------------------------------------------

*run_script <"指令碼程式碼">{,<角色編號>};

用於立刻執行指定的指令碼程式碼, 錯誤的使用該指令將導致程式異常 (風險指令)

指令碼程式碼:
	需要執行的指令碼程式碼
	雙引號 " 的左側需要新增 \ 進行轉義
	指令碼程式碼的左右可以選擇使用 {} 括起來

使用示例:

	prontera,107,234,4	script	run_script_test	123,{
		mes "[Tester]";
		
		// 直接傳遞指令碼使用
		run_script "mes \"Here is the script\";";
		
		// 可以傳遞左右被 {} 括起來的指令碼
		run_script "{ mes \"script with {}\"; }";
		
		// 支援道具的 AegisName
		run_script "getitem \"Apple\", 1;";
		
		// 支援指令碼常量 (如 BaseLevel)
	run_script "mes \"My Base Level = \" + BaseLevel;";
		
		close;
	}

返回值:
	成功返回 1, 失敗返回 0

--------------------------------------------------------------

*setequipcardid <EQI裝備位置>,<卡槽編號>,<物品編號>{,<角色編號>};
*setequipcardid <EQI裝備位置>,<卡槽編號>,<"物品名稱">{,<角色編號>};

設定指定位置裝備的卡片編號

EQI裝備位置:
	是指 EQI_* 開頭的位置常量, 可參考 doc/script_commands.txt

卡槽編號:
	0 - 第一個卡槽
	1 - 第二個卡槽
	2 - 第三個卡槽
	3 - 第四個卡槽

物品編號/"物品名稱":
	多型別引數. 可以填寫數值型別的道具編號, 或者字串型別的道具名稱.
	推薦使用道具編號, 相較而言結果會更加準確.
	
	若設定為 0 則表示移除該卡槽上的道具

返回值:
	成功返回 1, 失敗返回 0

注意事項:
	- 每次設定成功都會導致玩家進行一次角色能力重算
	- 可以設定非卡片道具, 例如把華麗短劍 (1231) 設定到另一件裝備上
	  - 並且華麗短劍的 Script 也會被正常執行 (Int + 5)
	- 可以設定超出裝備洞數的位置, 3 洞武器你可以在第四個卡槽設定道具
	- 設定為 0 移除道具(卡片)時, 不會在揹包新增對應的道具(卡片)
	- 無需提前在揹包中準備需要設定道具(卡片)

--------------------------------------------------------------

*unitmovepos <遊戲單位編號>,<目的地 X 座標>,<目的地 Y 座標>;

將指定的單位移動到其當前所在地圖的指定座標

遊戲單位編號:
	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的物件只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>

目的地 X 座標:
	想要將目標移動到它當前所在地圖的哪個 X 座標

目的地 Y 座標:
	想要將目標移動到它當前所在地圖的哪個 Y 座標

返回值:
	該指令無論執行成功與否, 都不會有返回值

注意事項:
	- 可以將玩家移動到 [無法移動] 的區域中去
	- 將玩家送到 [無法移動] 的區域會導致玩家被卡在牆裡
	  - 移動前可透過 checkcell 指令碼指令對目標單元格
	    是否具備 cell_chkpass 屬性來判斷目標格子是否可移動
	  - 若玩家所在的 [無法移動] 位置緊挨著一個 [可移動] 格子,
	    那麼在玩家移動的時候其實是能繞出來的
	- 當 monster_stuck_warning 戰鬥配置選項啟用時,
	  若魔物卡在 [不可移動] 嘗試移動失敗超過 1000 次地圖伺服器
	  就會出現警告並且瞬移魔物以讓它恢復自由
	  - 若你就希望魔物卡在原地, 也不希望關閉上面提到的戰鬥配置選項,
	    那麼可以對魔物使用 unitblockmove 禁止它嘗試移動

--------------------------------------------------------------

